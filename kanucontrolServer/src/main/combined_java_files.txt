package com.kcserver.dto;

import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for Mitglied entity with essential attributes.
 */
@Data
@NoArgsConstructor
public class MitgliedDTO {

    private Long id;                  // ID of the Mitglied record
    private Long personId;            // ID of the associated Person
    private Long vereinId;            // ID of the associated Verein
    private String vereinName;        // Name of the associated Verein
    private String vereinAbk;         // Abbreviation of the Verein
    private String funktion;          // Role of the person in the Verein
    private Boolean hauptVerein;      // Indicates if this is the main Verein

    // Custom Constructor
    public MitgliedDTO(Long personId, Long vereinId, String vereinName, String vereinAbk, String funktion, Boolean hauptVerein) {
        this.personId = personId;
        this.vereinId = vereinId;
        this.vereinName = vereinName;
        this.vereinAbk = vereinAbk;
        this.funktion = funktion;
        this.hauptVerein = hauptVerein;
    }
}package com.kcserver.dto;

import lombok.*;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PersonDTO {
    private Long id; // Matches 'id' in Person
    private String name; // Matches 'name' in Person
    private String vorname; // Matches 'vorname' in Person
    private String strasse; // Matches 'strasse' in Person
    private String plz; // Matches 'plz' in Person
    private String ort; // Matches 'ort' in Person
    private String telefon; // Matches 'telefon' in Person
    private String bankName; // Matches 'bankName' in Person
    private String iban; // Matches 'iban' in Person
    private String bic; // Matches 'bic' in Person

    @Getter
    @Setter
    private List<MitgliedDTO> mitgliedschaften; // New field for memberships

}package com.kcserver.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VereinDTO {
    private Long id;         // ID of the Verein
    private String name;     // Name of the Verein
    private String abk;      // Abbreviation of the Verein
    private String strasse;  // Street address
    private String plz;      // Postal code
    private String ort;      // City
    private String telefon;  // Phone number
    private String bankName; // Name of the bank (optional)
    private String kontoInhaber; // Account holder name (optional)
    private String kiAnschrift;  // Address of the account holder (optional)
    private String iban; // Matches 'iban' in Verein
    private String bic; // Matches 'bic' in Verein

}package com.kcserver.repository;

import com.kcserver.entity.Verein;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface VereinRepository extends JpaRepository<Verein, Long> {

    /**
     * Finds a list of Verein entities by their exact name.
     *
     * @param name the name of the Verein
     * @return a list of Verein entities
     */
    List<Verein> findByName(String name);

    /**
     * Finds a single Verein entity by its exact name.
     *
     * @param name the name of the Verein
     * @return a Verein entity
     */
    Verein findByNameIs(String name);

    /**
     * Finds a list of Verein entities whose name starts with a specific prefix.
     *
     * @param prefix the prefix to search for
     * @return a list of Verein entities
     */
    List<Verein> findByNameStartingWith(String prefix);

    /**
     * Finds all Verein entities located in a specific city (ort).
     *
     * @param ort the city to search for
     * @return a list of Verein entities
     */
    List<Verein> findByOrt(String ort);

    /**
     * Finds all Verein entities located in a specific postal code (plz).
     *
     * @param plz the postal code to search for
     * @return a list of Verein entities
     */
    List<Verein> findByPlz(String plz);

    /**
     * Finds all Verein entities by a specific abbreviation (abk).
     *
     * @param abk the abbreviation to search for
     * @return a list of Verein entities
     */
    List<Verein> findByAbk(String abk);
}package com.kcserver.repository;

import com.kcserver.entity.Person;
import com.kcserver.projection.PersonWithMitgliedschaften;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import java.util.List;

@RepositoryRestResource(excerptProjection = PersonWithMitgliedschaften.class)
public interface PersonRepository extends JpaRepository<Person, Long> {

    /**
     * Finds a list of Person entities by their last name.
     *
     * @param name the last name to search for
     * @return a list of Person entities
     */
    List<Person> findByName(String name);

    /**
     * Finds a single Person entity by their exact last name.
     *
     * @param name the exact last name to search for
     * @return a Person entity
     */
    Person findByNameIs(String name);

    /**
     * Finds a single Person entity by both first and last name.
     *
     * @param vorname the first name
     * @param name    the last name
     * @return a Person entity
     */
    Person findByVornameAndName(String vorname, String name);

    /**
     * Finds a list of Person entities whose last name starts with a specific prefix.
     *
     * @param prefix the prefix to search for
     * @return a list of Person entities
     */
    List<Person> findByNameStartingWith(String prefix);

    /**
     * Finds a list of Person entities whose first name starts with a specific prefix.
     *
     * @param prefix the prefix to search for
     * @return a list of Person entities
     */
    List<Person> findByVornameStartingWith(String prefix);

    /**
     * Finds all Person entities living in a specific city (ort).
     *
     * @param ort the city to search for
     * @return a list of Person entities
     */
    List<Person> findByOrt(String ort);

    /**
     * Finds all Person entities living in a specific postal code (plz).
     *
     * @param plz the postal code to search for
     * @return a list of Person entities
     */
    List<Person> findByPlz(String plz);
}package com.kcserver.repository;

import com.kcserver.entity.Mitglied;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MitgliedRepository extends JpaRepository<Mitglied, Long> {

        /**
         * Finds all Mitglied entities associated with a specific person by their ID.
         *
         * @param personId the ID of the person
         * @return a list of Mitglied entities
         */
        List<Mitglied> findByPersonMitgliedschaft_Id(Long personId);

        /**
         * Finds all Mitglied entities associated with a specific verein by their ID.
         *
         * @param vereinId the ID of the verein
         * @return a list of Mitglied entities
         */
        List<Mitglied> findByVereinMitgliedschaft_Id(Long vereinId);

        /**
         * Finds all Mitglied entities where `hauptVerein` is true.
         *
         * @param hauptVerein true or false indicating whether the Mitglied belongs to the main verein
         * @return a list of Mitglied entities
         */
        List<Mitglied> findByHauptVerein(boolean hauptVerein);

        @EntityGraph(attributePaths = {"personMitgliedschaft", "vereinMitgliedschaft"})
        List<Mitglied> findAll();
}package com.kcserver.sampleData.sampleService;

import com.kcserver.entity.Person;
import com.kcserver.repository.PersonRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SamplePersonService {
    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final PersonRepository personRepository;

    public SamplePersonService(PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    public void initialize() {
        if (personRepository.count() == 0) {
            logger.info("Loading sample Person data...");
            List<Person> samplePersons = List.of(
                    new Person("Schog", "Chris", "Ardennenstr. 82", "52076", "Aachen", "02408-81549", "Commerzbank Aachen", "DE671234567890", "DRESGENOW"),
                    new Person("Schog", "Hildegard", "Ardennenstr. 82", "52076", "Aachen", "02408-81549", "Commerzbank Aachen", "DE671234567890", "DRESGENOW")
            );
            personRepository.saveAll(samplePersons);
            logger.info("Sample Person data loaded successfully: {} records added.", samplePersons.size());
        } else {
            logger.info("Sample Person data already exists. Skipping initialization.");
        }
    }
}
package com.kcserver.sampleData.sampleService;

import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.repository.MitgliedRepository;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SampleMitgliedService {
    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final MitgliedRepository mitgliedRepository;
    private final PersonRepository personRepository;
    private final VereinRepository vereinRepository;

    public SampleMitgliedService(MitgliedRepository mitgliedRepository, PersonRepository personRepository,
                                 VereinRepository vereinRepository) {
        this.mitgliedRepository = mitgliedRepository;
        this.personRepository = personRepository;
        this.vereinRepository = vereinRepository;
    }
    public void initialize(){
        // Check if Mitglied data already exists
        if (mitgliedRepository.count() == 0) {
            logger.info("Loading sample Mitglied data...");

            // Retrieve an existing Person and Verein from the database
            Person existingPerson = personRepository.findByVornameAndName("Chris", "Schog");
            Verein existingVerein = vereinRepository.findByNameIs("Eschweiler Kanu Club");

            // Check if Person and Verein exist
            if (existingPerson != null && existingVerein != null) {
                logger.info("Person found: {} {}, ID: {}", existingPerson.getVorname(), existingPerson.getName(), existingPerson.getId());
                logger.info("Verein found: {}, ID: {}", existingVerein.getName(), existingVerein.getId());

                // Create a new Mitglied instance
                Mitglied mitglied = new Mitglied();
                mitglied.setPersonMitgliedschaft(existingPerson);
                mitglied.setVereinMitgliedschaft(existingVerein);
                mitglied.setFunktion("Geschäftsführer");
                mitglied.setHauptVerein(true);

                // Save the Mitglied instance
                mitgliedRepository.save(mitglied);
                logger.info("Sample Mitglied created: Person ID {}, Verein ID {}, Funktion {}",
                        mitglied.getPersonMitgliedschaft().getId(),
                        mitglied.getVereinMitgliedschaft().getId(),
                        mitglied.getFunktion());

                // Retrieve and log all HauptVerein members
                List<Mitglied> hauptVereinMembers = mitgliedRepository.findByHauptVerein(true);
                for (Mitglied member : hauptVereinMembers) {
                    logger.info("Member ID: {}, Person ID: {}, Verein ID: {}, Funktion: {}",
                            member.getId(),
                            member.getPersonMitgliedschaft().getId(),
                            member.getVereinMitgliedschaft().getId(),
                            member.getFunktion());
                }
            } else {
                logger.error("Required Person or Verein not found in the database. Sample Mitglied creation aborted.");
            }
        } else {
            logger.info("Sample Mitglied data already exists. Skipping initialization.");
        }
    }
}
package com.kcserver.sampleData.sampleService;

import com.kcserver.dto.VereinDTO;
import com.kcserver.entity.Verein;
import com.kcserver.repository.VereinRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SampleVereinService {
    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final VereinRepository vereinRepository;

    public SampleVereinService(VereinRepository vereinRepository) {
        this.vereinRepository = vereinRepository;
    }

    public void initialize() {
        if (vereinRepository.count() == 0) { // Check if data already exists
            logger.info("Loading sample Verein data...");

            List<VereinDTO> sampleVereinDTOs = List.of(
                    new VereinDTO(
                            null, // ID will be auto-generated
                            "Eschweiler Kanu Club",
                            "EKC",
                            "Ardennenstr. 82",
                            "52076",
                            "Aachen",
                            "02408-81549",
                            "VR Bank e.G.",
                            "Eschweiler Kanu Club e.V.",
                            "Ardennenstr. 82, 52076 Aachen",
                            "DE45391629806106794020",
                            "GENODED1WUR"
                    ),
                    new VereinDTO(
                            null,
                            "Spielvereinigung Boich Thum",
                            "SVBT",
                            "",
                            "",
                            "Boich",
                            "",
                            "",
                            "Spielvereinigung Boich Thum e.V.",
                            "",
                            "",
                            ""
                    ),
                    new VereinDTO(
                            null,
                            "Oberhausener Kanu Club",
                            "OKC",
                            "",
                            "",
                            "Oberhausen",
                            "",
                            "",
                            "Oberhausener Kanu Club e.V.",
                            "",
                            "",
                            ""
                    ),
                    new VereinDTO(
                            null,
                            "Kanu Club Grün Gelb e.V.",
                            "KCG",
                            "",
                            "",
                            "Köln",
                            "",
                            "",
                            "Kanu Club Grün Gelb e.V.",
                            "",
                            "",
                            ""
                    )
            );

            // Convert DTOs to entities and save them
            List<Verein> sampleVereine = sampleVereinDTOs.stream()
                    .map(this::convertToEntity)
                    .collect(Collectors.toList());

            vereinRepository.saveAll(sampleVereine);

            logger.info("Sample Verein data loaded successfully: {} records added.", sampleVereine.size());
        } else logger.info("Sample Verein data already exists. Skipping initialization.");
    }
    /**
     * Converts a VereinDTO to a Verein entity.
     *
     * @param vereinDTO The VereinDTO to convert.
     * @return The corresponding Verein entity.
     */
    private Verein convertToEntity(VereinDTO vereinDTO) {
        return new Verein(
                vereinDTO.getName(),
                vereinDTO.getAbk(),
                vereinDTO.getStrasse(),
                vereinDTO.getPlz(),
                vereinDTO.getOrt(),
                vereinDTO.getTelefon(),
                vereinDTO.getBankName(),
                vereinDTO.getKontoInhaber(),
                vereinDTO.getKiAnschrift(),
                vereinDTO.getIban(),
                vereinDTO.getBic()
        );
    }
}
package com.kcserver.sampleData;

import com.kcserver.sampleData.sampleService.SampleMitgliedService;
import com.kcserver.sampleData.sampleService.SamplePersonService;
import com.kcserver.sampleData.sampleService.SampleVereinService;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;

import javax.sql.DataSource;

// @Component
public class SampleDataInitializer {

    private static final Logger logger = LoggerFactory.getLogger(SampleDataInitializer.class);

    private final DataSource dataSource;
    private final SamplePersonService samplePersonService;
    private final SampleVereinService sampleVereinService;
    private final SampleMitgliedService sampleMitgliedService;

    // Constructor-based dependency injection
    public SampleDataInitializer(DataSource dataSource,
                                 SamplePersonService samplePersonService,
                                 SampleVereinService sampleVereinService,
                                 SampleMitgliedService sampleMitgliedService) {
        this.dataSource = dataSource;
        this.samplePersonService = samplePersonService;
        this.sampleVereinService = sampleVereinService;
        this.sampleMitgliedService = sampleMitgliedService;
    }

    @PostConstruct
    public void initializeSampleData() {
        // Load sample data
        loadSampleData();
    }

    private void loadSampleData() {
        logger.info("Loading sample data...");
        samplePersonService.initialize();
        sampleVereinService.initialize();
        sampleMitgliedService.initialize();
        logger.info("Sample data loaded successfully.");
    }

    @Bean
    public CommandLineRunner initializeDataRunner() {
        return args -> {
            logger.info("Starting CommandLineRunner-based data initialization...");
            loadSampleData();
            logger.info("CommandLineRunner-based data initialization completed.");
        };
    }
}package com.kcserver.config;

import com.kcserver.tenancy.TenantContext;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class SchemaTenantIdentifierResolver implements CurrentTenantIdentifierResolver {

    private static final Logger logger = LoggerFactory.getLogger(SchemaTenantIdentifierResolver.class);

    private static final String DEFAULT_TENANT = "kanu"; // Static tenant for initialization

    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenantId = TenantContext.getTenantId();
        if (tenantId == null) {
            logger.debug("No tenant ID found. Using default tenant: {}", DEFAULT_TENANT);
            return DEFAULT_TENANT;
        }
        logger.info("Resolved tenant identifier: {}", tenantId);
        return tenantId;
    }

    @Override
    public boolean validateExistingCurrentSessions() {
        return true;
    }
}package com.kcserver.config;

import com.kcserver.tenancy.TenantContext;
import liquibase.Liquibase;
import liquibase.database.DatabaseFactory;
import liquibase.database.jvm.JdbcConnection;
import liquibase.resource.ClassLoaderResourceAccessor;
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.*;

@Component
public class SchemaMultiTenantConnectionProvider
        extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl {

    private static final Logger logger = LoggerFactory.getLogger(SchemaMultiTenantConnectionProvider.class);
    private static final String DEFAULT_SCHEMA = "kanu";

    @Autowired
    private DataSource dataSource;

    @Override
    protected DataSource selectAnyDataSource() {
        return dataSource;
    }

    public SchemaMultiTenantConnectionProvider() {
        logger.info("SchemaMultiTenantConnectionProvider initialized.");
    }

    @Override
    protected DataSource selectDataSource(Object tenantIdentifier) {
        String tenantId = TenantContext.getTenantId();
        if (tenantId == null) {
            throw new IllegalStateException("Tenant identifier is not set. Ensure login is complete.");
        }
        return dataSource;
    }

    public Connection getTenantConnection(String tenantIdentifier) throws SQLException {
        logger.info("Getting connection for tenant: {}", tenantIdentifier);
        Connection connection = dataSource.getConnection();
        ensureSchemaExists(connection, tenantIdentifier);
        switchToSchema(connection, tenantIdentifier);
        return connection;
    }

    private boolean isSchemaInitialized(String tenantId) {
        String query = "SELECT initialized FROM schema_status WHERE tenant_id = ?";
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, tenantId);
            try (ResultSet resultSet = statement.executeQuery()) {
                return resultSet.next() && resultSet.getBoolean("initialized");
            }
        } catch (SQLException e) {
            throw new RuntimeException("Failed to check schema initialization status", e);
        }
    }

    private void markSchemaAsInitialized(String tenantId) {
        String query = "INSERT INTO schema_status (tenant_id, initialized) VALUES (?, TRUE) " +
                "ON DUPLICATE KEY UPDATE initialized = TRUE, last_updated = CURRENT_TIMESTAMP";
        try (Connection connection = dataSource.getConnection();
             PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, tenantId);
            statement.executeUpdate();
            logger.info("Marked schema as initialized for tenant: {}", tenantId);
        } catch (SQLException e) {
            throw new RuntimeException("Failed to mark schema as initialized", e);
        }
    }

    private void switchToSchema(Connection connection, String schema) throws SQLException {
        logger.info("Switching to schema: {}", schema);
        try (Statement statement = connection.createStatement()) {
            statement.execute("USE `" + schema + "`");
            logger.info("Switched to schema: {}", schema);
        }
    }

    public void ensureSchemaExists(Connection connection, String tenantIdentifier) throws SQLException {
        logger.info("Ensuring schema exists for tenant: {}", tenantIdentifier);

        // Create schema if it doesn't exist
        try (Statement statement = connection.createStatement()) {
            String createSchemaSQL = "CREATE SCHEMA IF NOT EXISTS `" + tenantIdentifier + "`";
            statement.execute(createSchemaSQL);
            logger.info("Schema ensured for tenant: {}", tenantIdentifier);
        }

        // Run migrations only if schema is not initialized
        if (!isSchemaInitialized(tenantIdentifier)) {
            runLiquibaseMigrations(tenantIdentifier);
            markSchemaAsInitialized(tenantIdentifier);
        } else {
            logger.info("Schema already initialized for tenant: {}", tenantIdentifier);
        }
    }

    private void runLiquibaseMigrations(String tenantIdentifier) throws SQLException {
        logger.info("Running Liquibase migrations for schema: {}", tenantIdentifier);

        try (Connection connection = dataSource.getConnection()) {
            switchToSchema(connection, tenantIdentifier);

            // Configure Liquibase
            Liquibase liquibase = new Liquibase(
                    "db/changelog/db.changelog-master.yaml",
                    new ClassLoaderResourceAccessor(),
                    DatabaseFactory.getInstance().findCorrectDatabaseImplementation(new JdbcConnection(connection))
            );

            // Set Liquibase parameters
            liquibase.setChangeLogParameter("schemaName", tenantIdentifier);
            logger.info("Liquibase schemaName set to: {}", tenantIdentifier);

            // Run migrations
            liquibase.update((String) null); // Using the current context
            logger.info("Liquibase migrations completed for schema: {}", tenantIdentifier);
        } catch (Exception e) {
            logger.error("Liquibase migration failed for schema: {}", tenantIdentifier, e);
            throw new SQLException("Failed to run Liquibase migrations for schema: " + tenantIdentifier, e);
        }
    }

    @Override
    public boolean supportsAggressiveRelease() {
        return false;
    }
}package com.kcserver.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtDecoders;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Value("${spring.security.oauth2.resourceserver.jwt.issuer-uri:http://localhost:9080/realms/KanuControl}")
    private String issuerUri;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable()) // Disable CSRF
                .cors(cors -> {}) // Enable CORS configuration
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/public/**").permitAll() // Allow public endpoints
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll() // Allow CORS preflight
                        .anyRequest().authenticated() // Require authentication for other endpoints
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .decoder(jwtDecoder()) // Explicitly set the JWT decoder
                        )
                ); // Enable JWT-based authentication

        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        return JwtDecoders.fromIssuerLocation(issuerUri); // Configure JWT decoder
    }
}package com.kcserver.config;

import jakarta.persistence.EntityManagerFactory;
import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.hibernate.cfg.AvailableSettings;
import org.springframework.context.annotation.Bean;

import javax.sql.DataSource;
import java.util.Map;
import java.util.HashMap;

@Configuration
public class MultiTenantConfig {

    @Autowired
    private DataSource dataSource;

    @Autowired
    private MultiTenantConnectionProvider multiTenantConnectionProvider;

    @Autowired
    private CurrentTenantIdentifierResolver tenantIdentifierResolver;

    // No direct usage of org.hibernate.SessionFactory
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.kcserver");
        em.setJpaVendorAdapter(new HibernateJpaVendorAdapter());

        // Force Spring to use the Jakarta EntityManagerFactory
        em.setEntityManagerFactoryInterface(EntityManagerFactory.class);

        Map<String, Object> properties = new HashMap<>();
        properties.put(AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER, multiTenantConnectionProvider);
        properties.put(AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, tenantIdentifierResolver);
        properties.put(AvailableSettings.SHOW_SQL, true);
        properties.put(AvailableSettings.FORMAT_SQL, true);

        em.setJpaPropertyMap(properties);
        return em;
    }
}package com.kcserver.config;

import com.kcserver.tenancy.TenantResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationListener;
import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Component;

@Component
public class AuthenticationSuccessListener implements ApplicationListener<AuthenticationSuccessEvent> {

    private final TenantResolver tenantResolver;
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationSuccessListener.class);

    public AuthenticationSuccessListener(TenantResolver tenantResolver) {
        this.tenantResolver = tenantResolver;
    }

    @Override
    public void onApplicationEvent(AuthenticationSuccessEvent event) {
        logger.info("AuthenticationSuccessEvent triggered. Resolving tenant...");

        Authentication authentication = event.getAuthentication();

        if (authentication == null || !(authentication.getPrincipal() instanceof Jwt)) {
            logger.error("Authentication is invalid or principal is not a Jwt. Principal: {}",
                    authentication != null ? authentication.getPrincipal() : "null");
            throw new IllegalStateException("Authentication is null or invalid.");
        }

        try {
            // Resolve the tenant from the authentication
            tenantResolver.resolveTenantFromAuthentication(authentication);
            logger.info("Tenant successfully resolved after login.");
        } catch (Exception e) {
            logger.error("Error resolving tenant after login: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to resolve tenant after login", e);
        }
    }
}package com.kcserver.config;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class CustomJwtAuthenticationConverter implements Converter<Jwt, Collection<GrantedAuthority>> {

    @Override
    public Collection<GrantedAuthority> convert(Jwt jwt) {
        // Extract roles or groups from JWT claims
        List<String> groups = jwt.getClaimAsStringList("groups"); // Replace "groups" with your claim name

        if (groups == null) {
            return List.of();
        }

        return groups.stream()
                .map(SimpleGrantedAuthority::new) // Map groups/roles to GrantedAuthority
                .collect(Collectors.toList());
    }
}
package com.kcserver.config;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {

    @Bean
    @Primary
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/kanu?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC");
        config.setUsername("root");
        config.setPassword("CHsab581_mysql");
        config.setDriverClassName("com.mysql.cj.jdbc.Driver");
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);
        return new HikariDataSource(config);
    }
}package com.kcserver.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins(
                        "http://localhost:3000",
                        "http://localhost:5173",
                        "http://your-production-url.com"
                ) // Add production URL(s) here
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // Include OPTIONS for preflight requests
                .allowedHeaders("*") // Allow all headers
                .allowCredentials(true); // Allow cookies and credentials
    }
}package com.kcserver.entity;

import jakarta.persistence.Column;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;

import java.time.LocalDateTime;

@MappedSuperclass
public abstract class Auditable {

    @Column(name = "created_date", updatable = false)
    private LocalDateTime createdDate;

    @Column(name = "last_modified_date")
    private LocalDateTime lastModifiedDate;

    @PrePersist
    public void prePersist() {
        this.createdDate = LocalDateTime.now();
        this.lastModifiedDate = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate() {
        this.lastModifiedDate = LocalDateTime.now();
    }

    // Getters and setters

}package com.kcserver.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.*;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@Table(name = "mitglied", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"person_id", "verein_id"})
})
public class Mitglied extends Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    @Column(name = "id")
    private Long id;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "verein_id", nullable = false)
    @ToString.Exclude
    private Verein vereinMitgliedschaft;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "person_id", nullable = false)
    @ToString.Exclude
    private Person personMitgliedschaft;

    @Column(name = "funktion")
    private String funktion;

    @NotNull
    @Column(name = "haupt_verein")
    private Boolean hauptVerein;

    // Constructor with specific fields
    public Mitglied(Verein vereinMitgliedschaft, Person personMitgliedschaft, String funktion, Boolean hauptVerein) {
        this.vereinMitgliedschaft = vereinMitgliedschaft;
        this.personMitgliedschaft = personMitgliedschaft;
        this.funktion = funktion;
        this.hauptVerein = hauptVerein;
    }

    public boolean isHauptVerein() {
        return hauptVerein;
    }

    public void setHauptVerein(boolean hauptVerein) {
        this.hauptVerein = hauptVerein;
    }

    // Custom setter for Verein
    public void setVerein(Verein verein) {
        this.vereinMitgliedschaft = verein;
    }

    // Custom getter for Verein
    public Verein getVerein() {
        return this.vereinMitgliedschaft;
    }

    // Custom setter for Person
    public void setPerson(Person person) {
        this.personMitgliedschaft = person;
    }

    // Custom getter for Person
    public Person getPerson() {
        return this.personMitgliedschaft;
    }
}package com.kcserver.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@Table(name = "person")
@Entity
public class Person extends Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    @Column(name = "id")
    private Long id;

    @NotNull
    @Size(min = 2, max = 100)
    @Column(name = "name")
    private String name;

    @NotNull
    @Size(min = 2, max = 100)
    @Column(name = "vorname")
    private String vorname;

    @Column(name = "strasse")
    private String strasse;

    @Column(name = "plz")
    private String plz;

    @Column(name = "ort")
    private String ort;

    @Column(name = "telefon")
    private String telefon;

    @Size(max = 255)
    @Column(name = "bank_name")
    private String bankName;

    // @Pattern(regexp = "^[A-Z0-9]{22}$") // Validate IBAN with a length of 22 (standard for many countries)
    @Column(name = "iban")
    private String iban;

    // @Pattern(regexp = "^[A-Z0-9]{8,11}$") // Validate BIC format with length between 8-11
    @Column(name = "bic")
    private String bic;

    @OneToMany(mappedBy = "personMitgliedschaft", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Mitglied> mitgliedschaften = new ArrayList<>(); // Initialize with an empty list

    // Helper method to add a Mitglied
    public void addMitglied(Mitglied mitglied) {
        mitgliedschaften.add(mitglied);
        mitglied.setPerson(this);
    }

    // Helper method to remove a Mitglied
    public void removeMitglied(Mitglied mitglied) {
        mitgliedschaften.remove(mitglied);
        mitglied.setPerson(null);
    }


    public
    Person(String name, String vorname, String strasse, String plz, String ort,
           String telefon, String bankName, String iban, String bic) {
        this.name = name;
        this.vorname = vorname;
        this.strasse = strasse;
        this.plz = plz;
        this.ort = ort;
        this.telefon = telefon;
        this.bankName = bankName;
        this.iban = iban;
        this.bic = bic;
    }
}package com.kcserver.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.*;

@Data
@Entity(name = "verein")
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"iban", "bic"}) // Optionally exclude sensitive fields from string representation
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@Table
public class Verein extends Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    @Column(name = "id")
    private Long id;

    @NotNull
    @Size(min = 2, max = 100)
    @Column(name = "name")
    private String name;

    @NotNull
    @Size(min = 1, max = 10)
    @Column(name = "abk")
    private String abk;

    @Column(name = "strasse")
    private String strasse;

    @Column(name = "plz")
    private String plz;

    @Column(name = "ort")
    private String ort;

    @Column(name = "telefon")
    private String telefon;

    @Size(max = 255)
    @Column(name = "bank_name")
    private String bankName;

    @Size(max = 255)
    @Column(name = "konto_inhaber")
    private String kontoInhaber;

    @Size(max = 255)
    @Column(name = "ki_anschrift")
    private String kiAnschrift;

    // @Pattern(regexp = "^[A-Z0-9]+$", message = "Invalid IBAN format")
    @Column(name = "iban")
    private String iban;

    // @Pattern(regexp = "^[A-Z0-9]+$", message = "Invalid BIC format")
    @Column(name = "bic")
    private String bic;


    public
    Verein(String name, String abk, String strasse, String plz, String ort,
           String telefon, String bankName, String kontoInhaber,
           String kiAnschrift, String iban, String bic) {
        this.name = name;
        this.abk = abk;
        this.strasse = strasse;
        this.plz = plz;
        this.ort = ort;
        this.telefon = telefon;
        this.bankName = bankName;
        this.kontoInhaber = kontoInhaber;
        this.kiAnschrift = kiAnschrift;
        this.iban = iban;
        this.bic = bic;
    }
}package com.kcserver.tenancy;

public class TenantContext {

    private static final ThreadLocal<String> currentTenant = new ThreadLocal<>();

    // Set the tenant identifier
    public static void setTenantId(String tenantId) {
        currentTenant.set(tenantId);
    }

    // Get the tenant identifier
    public static String getTenantId() {
        return currentTenant.get();
    }

    // Clear the tenant identifier (important to avoid memory leaks)
    public static void clear() {
        currentTenant.remove();
    }


}package com.kcserver.tenancy;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class TenantFilter implements Filter {

    private final TenantResolver tenantResolver;

    public TenantFilter(TenantResolver tenantResolver) {
        this.tenantResolver = tenantResolver;
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // Resolve tenant ID and set it in a context or thread-local storage
        String tenantId = tenantResolver.resolveTenantFromToken();

        // Optionally, store tenant ID in a thread-local or context
        TenantContext.setTenantId(tenantId);

        // Continue filter chain
        chain.doFilter(request, response);
    }
}package com.kcserver.tenancy;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class TenantOnboardingService {

    @Autowired
    private TenantDatabaseService tenantDatabaseService;

    public void onboardTenant(String tenantName) {
        tenantDatabaseService.ensureSchemaExists(tenantName);
    }
}
package com.kcserver.tenancy;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.Statement;

@Service
public class TenantDatabaseService {

    @Autowired
    private DataSource dataSource;

    public void ensureSchemaExists(String schemaName) {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {
            // Create the schema if it doesn't exist
            statement.execute(String.format("CREATE SCHEMA IF NOT EXISTS `%s`", schemaName));
            System.out.println("Schema ensured: " + schemaName);
        } catch (Exception e) {
            throw new RuntimeException("Failed to ensure schema: " + schemaName, e);
        }
    }
}package com.kcserver.tenancy;

import com.kcserver.service.LoginService;
import jakarta.persistence.EntityManagerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class TenantResolver {

    private static final Logger logger = LoggerFactory.getLogger(TenantResolver.class);

    @Autowired
    private LoginService loginService;

    @Autowired
    private EntityManagerFactory entityManagerFactory;

    public void resolveTenantFromAuthentication(Authentication authentication) {
        if (authentication == null || !(authentication.getPrincipal() instanceof Jwt)) {
            throw new IllegalStateException("Authentication is not valid or missing.");
        }

        Jwt jwt = (Jwt) authentication.getPrincipal();
        List<String> groups = jwt.getClaimAsStringList("groups");
        String tenantId = (groups != null && !groups.isEmpty()) ? groups.get(0) : null;

        if (tenantId == null || tenantId.isEmpty()) {
            throw new IllegalArgumentException("Tenant ID not found in authentication.");
        }

        logger.info("Resolved tenant ID: {}", tenantId);

        // Set tenant in context
        TenantContext.setTenantId(tenantId);
    }

    public String resolveTenantFromToken() {
        var authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !(authentication.getPrincipal() instanceof Jwt)) {
            throw new IllegalStateException("Authentication is not valid or missing.");
        }

        Jwt jwt = (Jwt) authentication.getPrincipal();
        List<String> groups = jwt.getClaimAsStringList("groups");
        String tenantId = (groups != null && !groups.isEmpty()) ? groups.get(0) : null;

        if (tenantId == null || tenantId.isEmpty()) {
            throw new IllegalArgumentException("Tenant ID not found in token.");
        }

        logger.info("Resolved tenant ID: {}", tenantId);

        // Set tenant in context
        TenantContext.setTenantId(tenantId);

        // Clear Hibernate cache
        entityManagerFactory.getCache().evictAll();

        // Prepare schema
        loginService.handleLogin(tenantId);

        return tenantId; // Ensure it returns the tenant ID
    }
}package com.kcserver.mapper;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.dto.PersonDTO;
import com.kcserver.dto.VereinDTO;
import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import org.mapstruct.*;

@Mapper(
        componentModel = "spring",
        uses = {PersonRepository.class, VereinRepository.class})
public interface EntityMapper {

    // Person Mappings
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "vorname", source = "vorname")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    PersonDTO toPersonDTO(Person person);

    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "vorname", source = "vorname")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    Person toPersonEntity(PersonDTO personDTO);

    @Mapping(target = "id", ignore = true)
    void updatePersonFromDTO(PersonDTO personDTO, @MappingTarget Person person);

    // Verein Mappings
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "abk", source = "abk")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "kontoInhaber", source = "kontoInhaber")
    @Mapping(target = "kiAnschrift", source = "kiAnschrift")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    VereinDTO toVereinDTO(Verein verein);

    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "abk", source = "abk")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "kontoInhaber", source = "kontoInhaber")
    @Mapping(target = "kiAnschrift", source = "kiAnschrift")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    Verein toVereinEntity(VereinDTO vereinDTO);

    @Mapping(target = "id", ignore = true)
    void updateVereinFromDTO(VereinDTO vereinDTO, @MappingTarget Verein verein);

    // Mitglied Mappings
    @Mapping(source = "personMitgliedschaft.id", target = "personId")
    @Mapping(source = "vereinMitgliedschaft.id", target = "vereinId")
    @Mapping(source = "vereinMitgliedschaft.name", target = "vereinName")
    @Mapping(source = "vereinMitgliedschaft.abk", target = "vereinAbk")
    @Mapping(source = "funktion", target = "funktion")
    @Mapping(source = "hauptVerein", target = "hauptVerein")
    MitgliedDTO toMitgliedDTO(Mitglied mitglied);

    @Mapping(target = "personMitgliedschaft", ignore = true) // Explicitly ignore
    @Mapping(target = "vereinMitgliedschaft", ignore = true) // Explicitly ignore
    @Mapping(target = "person", ignore = true) // Explicitly ignore
    @Mapping(target = "verein", ignore = true) // Explicitly ignore
    @Mapping(source = "funktion", target = "funktion")
    @Mapping(source = "hauptVerein", target = "hauptVerein")
    Mitglied toMitgliedEntity(MitgliedDTO mitgliedDTO);

    @AfterMapping
    default void mapMitgliedAssociations(MitgliedDTO mitgliedDTO, @MappingTarget Mitglied mitglied,
                                         @Context PersonRepository personRepository,
                                         @Context VereinRepository vereinRepository) {
        if (mitgliedDTO.getPersonId() != null) {
            Person person = personRepository.findById(mitgliedDTO.getPersonId())
                    .orElseThrow(() -> new IllegalArgumentException("Invalid person ID"));
            mitglied.setPersonMitgliedschaft(person);
        }
        if (mitgliedDTO.getVereinId() != null) {
            Verein verein = vereinRepository.findById(mitgliedDTO.getVereinId())
                    .orElseThrow(() -> new IllegalArgumentException("Invalid verein ID"));
            mitglied.setVereinMitgliedschaft(verein);
        }
    }
}package com.kcserver.controller;

import com.kcserver.dto.VereinDTO;
import com.kcserver.service.VereinService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/verein")
public class VereinController {

    private final VereinService vereinService;

    @Autowired
    public VereinController(VereinService vereinService) {
        this.vereinService = vereinService;
    }

    /**
     * Retrieve all Vereine as VereinDTOs.
     *
     * @return List of VereinDTOs.
     */
    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<VereinDTO>> getAllVereine() {
        List<VereinDTO> vereinDTOs = vereinService.getAllVereine();
        return ResponseEntity.ok(vereinDTOs);
    }

    /**
     * Retrieve a Verein by its ID as VereinDTO.
     *
     * @param id The ID of the Verein.
     * @return The VereinDTO or 404 if not found.
     */
    @GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<VereinDTO> getVereinById(@PathVariable Long id) {
        VereinDTO vereinDTO = vereinService.getVerein(id);
        return ResponseEntity.ok(vereinDTO);
    }

    /**
     * Create a new Verein from a VereinDTO.
     *
     * @param vereinDTO The VereinDTO to be created.
     * @return The created VereinDTO.
     */
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<VereinDTO> createVerein(@Valid @RequestBody VereinDTO vereinDTO) {
        VereinDTO createdVereinDTO = vereinService.createVerein(vereinDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdVereinDTO);
    }

    /**
     * Update an existing Verein by its ID using VereinDTO.
     *
     * @param id            The ID of the Verein to be updated.
     * @param updatedVereinDTO The updated VereinDTO data.
     * @return The updated VereinDTO or 404 if not found.
     */
    @PutMapping(value = "/{id}", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<VereinDTO> updateVerein(@PathVariable Long id, @Valid @RequestBody VereinDTO updatedVereinDTO) {
        VereinDTO updatedVereinDTOResult = vereinService.updateVerein(id, updatedVereinDTO);
        return ResponseEntity.ok(updatedVereinDTOResult);
    }

    /**
     * Delete a Verein by its ID.
     *
     * @param id The ID of the Verein to delete.
     * @return No content if successful, or 404 if not found.
     */
    @DeleteMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Void> deleteVerein(@PathVariable Long id) {
        boolean isDeleted = vereinService.deleteVerein(id);
        if (isDeleted) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }
}
package com.kcserver.controller;

import com.kcserver.dto.PersonDTO;
import com.kcserver.tenancy.TenantContext;
import com.kcserver.service.PersonService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/person")
public class PersonController {

    private final PersonService personService;

    private static final Logger logger = LoggerFactory.getLogger(PersonController.class);

    @Autowired
    public PersonController(PersonService personService) {
        this.personService = personService;
    }

    /**
     * Retrieve all persons as PersonDTOs, including their Mitgliedschaften and related Verein data.
     *
     * @return List of PersonDTOs.
     */
    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<PersonDTO>> getAllPersons() {
        List<PersonDTO> personDTOs = personService.getAllPersonsWithDetails();
        logger.info("Current Tenant: {}", TenantContext.getTenantId());
        return ResponseEntity.ok(personDTOs);
    }

    /**
     * Retrieve a person by their ID as PersonDTO, including their Mitgliedschaften and related Verein data.
     *
     * @param id The ID of the person.
     * @return The PersonDTO or 404 if not found.
     */
    @GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<PersonDTO> getPersonById(@PathVariable Long id) {
        PersonDTO personDTO = personService.getPersonWithDetails(id);
        logger.info("Current Tenant: {}", TenantContext.getTenantId());
        return ResponseEntity.ok(personDTO);
    }

    /**
     * Create a new person from a PersonDTO.
     *
     * @param personDTO The PersonDTO to be created.
     * @return The created PersonDTO.
     */
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<PersonDTO> createPerson(@Valid @RequestBody PersonDTO personDTO) {
        PersonDTO createdPersonDTO = personService.createPerson(personDTO);
        logger.info("Current Tenant: {}", TenantContext.getTenantId());
        return ResponseEntity.status(HttpStatus.CREATED).body(createdPersonDTO);
    }

    /**
     * Update an existing person by their ID using PersonDTO.
     *
     * @param id         The ID of the person to be updated.
     * @param personDTO The updated PersonDTO data.
     * @return The updated PersonDTO or 404 if not found.
     */
    @PutMapping(value = "/{id}", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<PersonDTO> updatePerson(@PathVariable Long id, @Valid @RequestBody PersonDTO personDTO) {

        logger.info("Received PUT request to update person with ID: {} and payload: {}", id, personDTO);

        try {
            PersonDTO updatedPerson = personService.updatePerson(id, personDTO);
            logger.info("Successfully updated person with ID: {}", id);
            logger.info("Current Tenant: {}", TenantContext.getTenantId());
            return ResponseEntity.ok(updatedPerson);
        } catch (Exception e) {
            logger.error("Error updating person with ID: {}", id, e);
            throw e; // Let Spring handle and return the appropriate error response
        }
    }

    /**
     * Delete a person by their ID.
     *
     * @param id The ID of the person to delete.
     * @return No content if successful, or 404 if not found.
     */
    @DeleteMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Void> deletePerson(@PathVariable Long id) {
        boolean isDeleted = personService.deletePerson(id);
        if (isDeleted) {
            logger.info("Current Tenant: {}", TenantContext.getTenantId());
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }
}
package com.kcserver.controller;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.service.MitgliedService;
import com.kcserver.service.PersonService;
import com.kcserver.service.VereinService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/mitglied")
public class MitgliedController {

    private static final Logger logger = LoggerFactory.getLogger(MitgliedController.class);

    private final MitgliedService mitgliedService;
    private final PersonService personService;
    private final VereinService vereinService;

    @Autowired
    public MitgliedController(MitgliedService mitgliedService, PersonService personService, VereinService vereinService) {
        this.mitgliedService = mitgliedService;
        this.personService = personService;
        this.vereinService = vereinService;
    }

    /**
     * Creates a new Mitglied entity.
     *
     * @param mitgliedDTO the DTO containing Mitglied details
     * @return ResponseEntity with the created MitgliedDTO
     */
    @PostMapping
    public ResponseEntity<MitgliedDTO> createMitglied(@RequestBody @Valid MitgliedDTO mitgliedDTO) {
        try {
            // Validate that Person ID and Verein ID are not null
            Long personId = mitgliedDTO.getPersonId();
            Long vereinId = mitgliedDTO.getVereinId();

            if (personId == null || vereinId == null) {
                throw new IllegalArgumentException("Person ID and Verein ID must not be null");
            }

            // Fetch Person and Verein entities
            Person person = personService.getPersonEntityById(personId);
            Verein verein = vereinService.getVereinEntityById(vereinId);

            // Create the Mitglied and return the DTO
            MitgliedDTO createdMitgliedDTO = mitgliedService.createMitglied(
                    person,
                    verein,
                    mitgliedDTO.getFunktion(),
                    mitgliedDTO.getHauptVerein()
            );

            logger.info("Created new Mitglied: {}", createdMitgliedDTO);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdMitgliedDTO);
        } catch (IllegalArgumentException e) {
            logger.error("Validation error creating Mitglied: {}", e.getMessage());
            return ResponseEntity.badRequest().body(null);
        } catch (Exception e) {
            logger.error("Unexpected error creating Mitglied: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    /**
     * Retrieves all Mitglied entries for a given Person ID.
     *
     * @param personId the ID of the person
     * @return ResponseEntity containing a list of MitgliedDTOs
     */
    @GetMapping("/person/{personId}")
    public ResponseEntity<List<MitgliedDTO>> getMitgliedByPerson(@PathVariable @NotNull Long personId) {
        try {
            List<MitgliedDTO> mitgliedDTOs = mitgliedService.getMitgliedByPersonId(personId);

            logger.info("Retrieved {} Mitglied entries for Person ID {}", mitgliedDTOs.size(), personId);
            return ResponseEntity.ok(mitgliedDTOs);
        } catch (Exception e) {
            logger.error("Error retrieving Mitglied for Person ID {}: {}", personId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    /**
     * Retrieves all Mitglied entries for a given Verein ID.
     *
     * @param vereinId the ID of the Verein
     * @return ResponseEntity containing a list of MitgliedDTOs
     */
    @GetMapping("/verein/{vereinId}")
    public ResponseEntity<List<MitgliedDTO>> getMitgliedByVerein(@PathVariable @NotNull Long vereinId) {
        try {
            List<MitgliedDTO> mitgliedDTOs = mitgliedService.getMitgliedByVereinId(vereinId);

            logger.info("Retrieved {} Mitglied entries for Verein ID {}", mitgliedDTOs.size(), vereinId);
            return ResponseEntity.ok(mitgliedDTOs);
        } catch (Exception e) {
            logger.error("Error retrieving Mitglied for Verein ID {}: {}", vereinId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    /**
     * Deletes a Mitglied by its ID.
     *
     * @param mitgliedId the ID of the Mitglied to delete
     * @return ResponseEntity with no content if successful
     */
    @DeleteMapping("/{mitgliedId}")
    public ResponseEntity<Void> deleteMitglied(@PathVariable @NotNull Long mitgliedId) {
        try {
            mitgliedService.deleteMitglied(mitgliedId);
            logger.info("Deleted Mitglied with ID: {}", mitgliedId);
            return ResponseEntity.noContent().build();
        } catch (IllegalArgumentException e) {
            logger.error("Validation error deleting Mitglied with ID {}: {}", mitgliedId, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            logger.error("Unexpected error deleting Mitglied with ID {}: {}", mitgliedId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}package com.kcserver.controller;

import org.springframework.security.core.Authentication;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {

    @GetMapping("/api/test")
    public String test(Authentication authentication) {
        Jwt jwt = (Jwt) authentication.getPrincipal();
        return "Groups: " + jwt.getClaimAsStringList("groups");
    }
}
package com.kcserver.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class ApiController {
    @PreAuthorize("hasRole('api-role')")
    @GetMapping("/secured")
    public String securedEndpoint() {
        return "This is a secured endpoint";
    }
}

package com.kcserver.controller;

import com.kcserver.tenancy.TenantContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TenantController {

    @GetMapping("/api/active-schema")
    public String getActiveSchema() {
        String tenantId = TenantContext.getTenantId();
        return tenantId != null ? tenantId : "No tenant schema active";
    }
}package com.kcserver.service;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.repository.MitgliedRepository;
import com.kcserver.mapper.EntityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class MitgliedService {

    private final MitgliedRepository mitgliedRepository;
    private final EntityMapper mapper;

    @Autowired
    public MitgliedService(MitgliedRepository mitgliedRepository, EntityMapper mapper) {
        this.mitgliedRepository = mitgliedRepository;
        this.mapper = mapper;
    }

    /**
     * Creates a new Mitglied entity, saves it to the database, and returns the corresponding DTO.
     *
     * @param person      the person associated with the Mitglied
     * @param verein      the verein associated with the Mitglied
     * @param funktion    the role of the Mitglied
     * @param hauptVerein indicates whether this is the main verein for the person
     * @return the saved Mitglied as a DTO
     */
    public MitgliedDTO createMitglied(Person person, Verein verein, String funktion, Boolean hauptVerein) {
        if (person == null || verein == null) {
            throw new IllegalArgumentException("Person and Verein cannot be null");
        }

        Mitglied mitglied = new Mitglied();
        mitglied.setPersonMitgliedschaft(person);
        mitglied.setVereinMitgliedschaft(verein);
        mitglied.setFunktion(funktion);
        mitglied.setHauptVerein(hauptVerein);

        Mitglied savedMitglied = mitgliedRepository.save(mitglied);
        return mapper.toMitgliedDTO(savedMitglied);
    }

    /**
     * Updates an existing Mitglied entity.
     *
     * @param mitgliedId the ID of the Mitglied to update
     * @param funktion   the updated role of the Mitglied
     * @param hauptVerein indicates whether this is the main verein
     * @return the updated Mitglied as a DTO
     */
    public MitgliedDTO updateMitglied(Long mitgliedId, String funktion, Boolean hauptVerein) {
        Mitglied mitglied = mitgliedRepository.findById(mitgliedId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Mitglied not found"));

        mitglied.setFunktion(funktion);
        mitglied.setHauptVerein(hauptVerein);

        Mitglied updatedMitglied = mitgliedRepository.save(mitglied);
        return mapper.toMitgliedDTO(updatedMitglied);
    }

    /**
     * Retrieves all Mitglied entities associated with a specific Person and converts them to DTOs.
     *
     * @param personId the ID of the person
     * @return a list of MitgliedDTOs
     */
    public List<MitgliedDTO> getMitgliedByPersonId(Long personId) {
        return mitgliedRepository.findByPersonMitgliedschaft_Id(personId).stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves all Mitglied entities associated with a specific Verein and converts them to DTOs.
     *
     * @param vereinId the ID of the verein
     * @return a list of MitgliedDTOs
     */
    public List<MitgliedDTO> getMitgliedByVereinId(Long vereinId) {
        return mitgliedRepository.findByVereinMitgliedschaft_Id(vereinId).stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deletes a Mitglied by its ID.
     *
     * @param mitgliedId the ID of the Mitglied to delete
     */
    public void deleteMitglied(Long mitgliedId) {
        if (!mitgliedRepository.existsById(mitgliedId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Mitglied not found");
        }
        mitgliedRepository.deleteById(mitgliedId);
    }

    /**
     * Retrieves all Mitglieds and converts them to DTOs.
     *
     * @return a list of all MitgliedDTOs
     */
    public List<MitgliedDTO> getAllMitglieds() {
        return mitgliedRepository.findAll().stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList());
    }
}package com.kcserver.service;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.dto.PersonDTO;
import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.mapper.EntityMapper;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import com.kcserver.sampleData.sampleService.SamplePersonService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
public class PersonService {

    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final PersonRepository personRepository;
    private final VereinRepository vereinRepository;
    private final EntityMapper mapper;

    @Autowired
    public PersonService(PersonRepository personRepository, VereinRepository vereinRepository, EntityMapper mapper) {
        this.personRepository = personRepository;
        this.vereinRepository = vereinRepository;
        this.mapper = mapper;
    }

    /**
     * Retrieve all persons as PersonDTOs.
     *
     * @return List of PersonDTOs.
     */
    @Transactional(readOnly = true)
    public List<PersonDTO> getAllPersons() {
        return personRepository.findAll().stream()
                .map(mapper::toPersonDTO)
                .collect(Collectors.toList());
    }

    /**
     * Retrieve a person by their ID and return as PersonDTO.
     *
     * @param id The ID of the person.
     * @return The PersonDTO.
     * @throws ResponseStatusException if the person is not found.
     */
    public PersonDTO getPerson(long id) {
        Person person = personRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found"));
        return mapper.toPersonDTO(person);
    }

    /**
     * Retrieve a Person entity by its ID.
     *
     * @param id The ID of the person.
     * @return The Person entity.
     * @throws ResponseStatusException if the person is not found.
     */
    public Person getPersonEntityById(long id) {
        return personRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found"));
    }

    public PersonDTO getPersonWithDetails(long id) {
        Person person = personRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found"));

        PersonDTO personDTO = mapper.toPersonDTO(person);
        personDTO.setMitgliedschaften(person.getMitgliedschaften().stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList()));
        return personDTO;
    }
    @Transactional(readOnly = true)
    public List<PersonDTO> getAllPersonsWithDetails() {
        return personRepository.findAll().stream()
                .map(person -> {
                    PersonDTO personDTO = mapper.toPersonDTO(person);
                    personDTO.setMitgliedschaften(person.getMitgliedschaften().stream()
                            .map(mapper::toMitgliedDTO)
                            .collect(Collectors.toList()));
                    return personDTO;
                })
                .collect(Collectors.toList());
    }

    /**
     * Create a new person from PersonDTO.
     *
     * @param personDTO The PersonDTO to be created.
     * @return The created PersonDTO.
     */
    public PersonDTO createPerson(PersonDTO personDTO) {
        Person person = mapper.toPersonEntity(personDTO);

        // Handle Mitgliedschaften if provided
        if (personDTO.getMitgliedschaften() != null) {
            personDTO.getMitgliedschaften().forEach(mitgliedDTO -> {
                Verein verein = vereinRepository.findById(mitgliedDTO.getVereinId())
                        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));
                Mitglied mitglied = new Mitglied(
                        verein,
                        person,
                        mitgliedDTO.getFunktion(),
                        mitgliedDTO.getHauptVerein()
                );
                person.getMitgliedschaften().add(mitglied);
            });
        }

        Person savedPerson = personRepository.save(person);
        return mapper.toPersonDTO(savedPerson);
    }

    /**
     * Update an existing person by their ID using PersonDTO.
     *
     * @param id        The ID of the person to be updated.
     * @param personDTO The updated PersonDTO data.
     * @return The updated PersonDTO.
     * @throws ResponseStatusException if the person is not found.
     */
    public PersonDTO updatePerson(long id, PersonDTO personDTO) {
        logger.info("Updating person with ID: {} using data: {}", id, personDTO);

        Person existingPerson = personRepository.findById(id)
                .orElseThrow(() -> {
                    logger.error("Person with ID: {} not found", id);
                    return new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found");
                });

        logger.debug("Found person: {}", existingPerson);

        // Map DTO to entity
        mapper.updatePersonFromDTO(personDTO, existingPerson);
        logger.debug("Mapped fields from DTO to entity for ID: {}", id);

        // Clear existing Mitgliedschaften
        logger.info("Payload received for update: {}", personDTO);
        if (existingPerson.getMitgliedschaften() == null) {
            logger.error("Mitgliedschaften is null for person ID {}", id);
            existingPerson.setMitgliedschaften(new ArrayList<>());
        } else {
            logger.info("Existing Mitgliedschaften: {}", existingPerson.getMitgliedschaften());
            existingPerson.getMitgliedschaften().clear();
        }

        // Rebuild Mitgliedschaften from the DTO
        if (personDTO.getMitgliedschaften() != null) {
            // Map of existing Mitgliedschaften by Verein ID for quick lookup
            Map<Long, Mitglied> existingMitgliedMap = existingPerson.getMitgliedschaften().stream()
                    .collect(Collectors.toMap(m -> m.getVerein().getId(), Function.identity()));

            for (MitgliedDTO mitgliedDTO : personDTO.getMitgliedschaften()) {
                Verein verein = vereinRepository.findById(mitgliedDTO.getVereinId())
                        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));

                Mitglied mitglied = existingMitgliedMap.get(verein.getId());
                if (mitglied == null) {
                    // New Mitglied
                    mitglied = new Mitglied();
                    mitglied.setPerson(existingPerson);
                    mitglied.setVerein(verein);
                    existingPerson.getMitgliedschaften().add(mitglied);
                }

                // Update fields
                mitglied.setFunktion(mitgliedDTO.getFunktion());
                mitglied.setHauptVerein(mitgliedDTO.getHauptVerein());
            }

            // Remove Mitgliedschaften not in the DTO
            Set<Long> incomingVereinIds = personDTO.getMitgliedschaften().stream()
                    .map(MitgliedDTO::getVereinId)
                    .collect(Collectors.toSet());

            existingPerson.getMitgliedschaften().removeIf(m -> !incomingVereinIds.contains(m.getVerein().getId()));
        }

        Person updatedPerson = personRepository.save(existingPerson);
        logger.info("Successfully updated person with ID: {}", id);
        return mapper.toPersonDTO(updatedPerson);
    }
    /**
     * Delete a person by their ID.
     *
     * @param id The ID of the person to delete.
     * @return true if successful, false otherwise.
     */
    public boolean deletePerson(long id) {
        if (personRepository.existsById(id)) {
            personRepository.deleteById(id);
            return true;
        }
        return false;
    }
}package com.kcserver.service;

import com.kcserver.dto.VereinDTO;
import com.kcserver.entity.Verein;
import com.kcserver.repository.VereinRepository;
import com.kcserver.mapper.EntityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class VereinService {

    private final VereinRepository vereinRepository;
    private final EntityMapper mapper;

    @Autowired
    public VereinService(VereinRepository vereinRepository, EntityMapper mapper) {
        this.vereinRepository = vereinRepository;
        this.mapper = mapper;
    }

    /**
     * Retrieve all Vereine as VereinDTOs.
     *
     * @return List of VereinDTOs.
     */
    public List<VereinDTO> getAllVereine() {
        return vereinRepository.findAll().stream()
                .map(mapper::toVereinDTO)
                .collect(Collectors.toList());
    }

    /**
     * Retrieve a Verein by its ID and return as VereinDTO.
     *
     * @param id The ID of the Verein.
     * @return The VereinDTO.
     * @throws ResponseStatusException if the Verein is not found.
     */
    public VereinDTO getVerein(long id) {
        Verein verein = vereinRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));
        return mapper.toVereinDTO(verein);
    }

    /**
     * Retrieve a Verein entity by its ID.
     *
     * @param id The ID of the Verein.
     * @return The Verein entity.
     * @throws ResponseStatusException if the Verein is not found.
     */
    public Verein getVereinEntityById(long id) {
        return vereinRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));
    }

    /**
     * Create a new Verein from VereinDTO.
     *
     * @param vereinDTO The VereinDTO to be created.
     * @return The created VereinDTO.
     */
    public VereinDTO createVerein(VereinDTO vereinDTO) {
        Verein verein = mapper.toVereinEntity(vereinDTO);
        Verein savedVerein = vereinRepository.save(verein);
        return mapper.toVereinDTO(savedVerein);
    }

    /**
     * Update an existing Verein by its ID using VereinDTO.
     *
     * @param id        The ID of the Verein to be updated.
     * @param vereinDTO The updated VereinDTO data.
     * @return The updated VereinDTO.
     * @throws ResponseStatusException if the Verein is not found.
     */
    public VereinDTO updateVerein(long id, VereinDTO vereinDTO) {
        Verein existingVerein = vereinRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));

        mapper.updateVereinFromDTO(vereinDTO, existingVerein);

        Verein updatedVerein = vereinRepository.save(existingVerein);
        return mapper.toVereinDTO(updatedVerein);
    }

    /**
     * Delete a Verein by its ID.
     *
     * @param id The ID of the Verein to delete.
     * @return true if successful, false otherwise.
     */
    public boolean deleteVerein(long id) {
        if (vereinRepository.existsById(id)) {
            vereinRepository.deleteById(id);
            return true;
        }
        return false;
    }
}package com.kcserver.service;

import com.kcserver.config.SchemaMultiTenantConnectionProvider;
import com.kcserver.tenancy.TenantContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class LoginService {

    @Autowired
    private SchemaMultiTenantConnectionProvider schemaMultiTenantConnectionProvider;

    public void handleLogin(String tenantId) {
        TenantContext.setTenantId(tenantId);
        try {
            schemaMultiTenantConnectionProvider.getTenantConnection(tenantId);
        } catch (Exception e) {
            throw new RuntimeException("Failed to prepare tenant schema for tenant: " + tenantId, e);
        }
    }
}package com.kcserver.exception;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<String> handleDataIntegrityViolationException(DataIntegrityViolationException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body("Duplicate entry detected.");
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        // Fallback for unexpected exceptions
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred: " + ex.getMessage());
    }
}package com.kcserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.stereotype.Component;

@Configuration
@EnableAutoConfiguration
@ComponentScan
@Component
@EnableScheduling
@SpringBootApplication
public class KC_Server {

	public static void main(String[] args) {
		SpringApplication.run(KC_Server.class, args);
		System.out.println("KC Server is running...");
	}
}package com.kcserver.projection;

import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import org.springframework.data.rest.core.config.Projection;

import java.util.List;

@Projection(name = "personWithMitgliedschaften", types = {Person.class})
public interface PersonWithMitgliedschaften {
    String getName();
    String getVorname();
    String getStrasse();
    String getPlz();
    String getOrt();
    String getTelefon();
    String getBankName();
    String getIban();
    String getBic();

    List<MitgliedProjection> getMitgliedschaften();
}

@Projection(name = "mitgliedProjection", types = {Mitglied.class})
interface MitgliedProjection {
    Long getId();
    String getFunktion();
    Boolean getHauptVerein();
    VereinProjection getVereinMitgliedschaft();
}

@Projection(name = "vereinProjection", types = {Verein.class})
interface VereinProjection {
    Long getId();
    String getName();
    String getAbk();
}