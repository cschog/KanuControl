package com.kcserver.SampleData;

import com.kcserver.entity.Mitglied;
import com.kcserver.repository.MitgliedRepository;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import com.kcserver.sampleData.sampleService.SampleMitgliedService;
import com.kcserver.sampleData.sampleService.SamplePersonService;
import com.kcserver.sampleData.sampleService.SampleVereinService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@ActiveProfiles("test") // Use a separate test profile to avoid affecting production data
public class SampleMitgliedDataGesamt {

    @Autowired
    private MitgliedRepository mitgliedRepository;

    @Autowired
    private PersonRepository personRepository;

    @Autowired
    private VereinRepository vereinRepository;

    @Autowired
    private SamplePersonService samplePersonService;

    @Autowired
    private SampleVereinService sampleVereinService;

    @Autowired
    private SampleMitgliedService sampleMitgliedService;

    @BeforeEach
    void setUp() {
        // Clean up repositories before each test
        mitgliedRepository.deleteAll();
        personRepository.deleteAll();
        vereinRepository.deleteAll();

        // Run the services to initialize data
        samplePersonService.initialize();
        sampleVereinService.initialize();
    }

    @Test
    void shouldLoadSampleMitgliedData() {
        // Run the Mitglied service to initialize data
        sampleMitgliedService.initialize();

        // Verify Mitglied was created
        List<Mitglied> mitgliedList = mitgliedRepository.findAll();
        assertThat(mitgliedList).hasSize(1);

        Mitglied mitglied = mitgliedList.get(0);
        assertThat(mitglied.getPersonMitgliedschaft().getVorname()).isEqualTo("Chris");
        assertThat(mitglied.getVereinMitgliedschaft().getName()).isEqualTo("Eschweiler Kanu Club");
        assertThat(mitglied.getFunktion()).isEqualTo("Geschäftsführer");
        assertThat(mitglied.isHauptVerein()).isTrue();
    }

    @Test
    void shouldNotLoadSampleDataIfAlreadyExists() {
        // First run to insert data
        sampleMitgliedService.initialize();

        // Second run should not add duplicate data
        sampleMitgliedService.initialize();

        // Verify only one Mitglied exists
        List<Mitglied> mitgliedList = mitgliedRepository.findAll();
        assertThat(mitgliedList).hasSize(1);
    }
}package com.kcserver.config;

import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@TestConfiguration
class SecurityConfigTest {

    @Bean
    public SecurityFilterChain mockSecurityConfiguration(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable()) // Updated to use lambda syntax
                .authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                .build();
    }
}package com.kcserver.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.kcserver.KC_Server;
import com.kcserver.dto.MitgliedDTO;
import com.kcserver.dto.PersonDTO;
import com.kcserver.service.PersonService;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.util.List;

import static org.mockito.Mockito.*;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.jwt;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(classes = KC_Server.class)
@ActiveProfiles("test")
@AutoConfigureMockMvc
class PersonControllerIT {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private PersonService personService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void shouldReturnAllPersons() throws Exception {
        // Sample data
        List<PersonDTO> samplePersons = List.of(
                new PersonDTO(1L, "Schog", "Chris", "Ardennenstr. 82", "52076", "Aachen", "02408-81549",
                        "Commerzbank Aachen", "DE671234567890", "DRESGENOW",
                        List.of(new MitgliedDTO(1L, 1L, "Eschweiler Kanu Club", "EKC", "Geschäftsführer", true))),
                new PersonDTO(2L, "Schog", "Hildegard", "Ardennenstr. 82", "52076", "Aachen", "02408-81549",
                        "Commerzbank Aachen", "DE671234567890", "DRESGENOW", null)
        );

        when(personService.getAllPersonsWithDetails()).thenReturn(samplePersons);

        // Perform GET request with mock JWT authentication
        mockMvc.perform(get("/api/person")
                        .with(jwt().jwt(builder -> builder.claim("groups", List.of("Eschweiler Kanu Club"))))
                        .accept(MediaType.APPLICATION_JSON))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.length()").value(2))
                .andExpect(jsonPath("$[0].name").value("Schog"));

        verify(personService, times(1)).getAllPersonsWithDetails();
    }

    @Test
    void shouldCreateNewPerson() throws Exception {
        PersonDTO inputPerson = new PersonDTO(
                null, "Smith", "Jane", "High Street 100", "67890", "New Town",
                "987-654-3210", "Other Bank", "IBAN987", "BIC987", null
        );

        PersonDTO createdPerson = new PersonDTO(
                1L, "Smith", "Jane", "High Street 100", "67890", "New Town",
                "987-654-3210", "Other Bank", "IBAN987", "BIC987", null
        );

        when(personService.createPerson(Mockito.any(PersonDTO.class))).thenReturn(createdPerson);

        mockMvc.perform(post("/api/person")
                        .with(jwt().jwt(builder -> builder.claim("groups", List.of("Eschweiler Kanu Club"))))
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(inputPerson)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(1L))
                .andExpect(jsonPath("$.name").value("Smith"));

        verify(personService, times(1)).createPerson(Mockito.any(PersonDTO.class));
    }
}package com.kcserver.service;

import com.kcserver.dto.PersonDTO;
import com.kcserver.entity.Person;
import com.kcserver.mapper.EntityMapper;
import com.kcserver.repository.PersonRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.web.server.ResponseStatusException;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class PersonServiceTest {

    @Mock
    private PersonRepository personRepository;

    @Mock
    private EntityMapper mapper;

    @InjectMocks
    private PersonService personService;

    @Test
    void shouldReturnPersonDTOWhenPersonExists() {
        // Arrange
        Person person = new Person(1L, "Doe", "John", "Street 1", "12345", "City", "123456789", "Bank", "IBAN", "BIC", null);
        PersonDTO personDTO = new PersonDTO(1L, "Doe", "John", "Street 1", "12345", "City", "123456789", "Bank", "IBAN", "BIC", null);

        when(personRepository.findById(1L)).thenReturn(Optional.of(person));
        when(mapper.toPersonDTO(person)).thenReturn(personDTO);

        // Act
        PersonDTO result = personService.getPerson(1L);

        // Assert
        assertNotNull(result);
        assertEquals("Doe", result.getName());
        verify(personRepository).findById(1L);
        verify(mapper).toPersonDTO(person);
    }

    @Test
    void shouldThrowExceptionWhenPersonNotFound() {
        // Arrange
        when(personRepository.findById(1L)).thenReturn(Optional.empty());

        // Act & Assert
        assertThrows(ResponseStatusException.class, () -> personService.getPerson(1L));
    }
}package com.kcserver.dto;

import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for Mitglied entity with essential attributes.
 */
@Data
@NoArgsConstructor
public class MitgliedDTO {

    private Long id;                  // ID of the Mitglied record
    private Long personId;            // ID of the associated Person
    private Long vereinId;            // ID of the associated Verein
    private String vereinName;        // Name of the associated Verein
    private String vereinAbk;         // Abbreviation of the Verein
    private String funktion;          // Role of the person in the Verein
    private Boolean hauptVerein;      // Indicates if this is the main Verein

    // Custom Constructor
    public MitgliedDTO(Long personId, Long vereinId, String vereinName, String vereinAbk, String funktion, Boolean hauptVerein) {
        this.personId = personId;
        this.vereinId = vereinId;
        this.vereinName = vereinName;
        this.vereinAbk = vereinAbk;
        this.funktion = funktion;
        this.hauptVerein = hauptVerein;
    }
}package com.kcserver.dto;

import lombok.*;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PersonDTO {
    private Long id; // Matches 'id' in Person
    private String name; // Matches 'name' in Person
    private String vorname; // Matches 'vorname' in Person
    private String strasse; // Matches 'strasse' in Person
    private String plz; // Matches 'plz' in Person
    private String ort; // Matches 'ort' in Person
    private String telefon; // Matches 'telefon' in Person
    private String bankName; // Matches 'bankName' in Person
    private String iban; // Matches 'iban' in Person
    private String bic; // Matches 'bic' in Person

    @Getter
    @Setter
    private List<MitgliedDTO> mitgliedschaften; // New field for memberships

}package com.kcserver.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class VereinDTO {
    private Long id;         // ID of the Verein
    private String name;     // Name of the Verein
    private String abk;      // Abbreviation of the Verein
    private String strasse;  // Street address
    private String plz;      // Postal code
    private String ort;      // City
    private String telefon;  // Phone number
    private String bankName; // Name of the bank (optional)
    private String kontoInhaber; // Account holder name (optional)
    private String kiAnschrift;  // Address of the account holder (optional)
    private String iban; // Matches 'iban' in Verein
    private String bic; // Matches 'bic' in Verein

}package com.kcserver.repository;

import com.kcserver.entity.Verein;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface VereinRepository extends JpaRepository<Verein, Long> {

    /**
     * Finds a list of Verein entities by their exact name.
     *
     * @param name the name of the Verein
     * @return a list of Verein entities
     */
    List<Verein> findByName(String name);

    /**
     * Finds a single Verein entity by its exact name.
     *
     * @param name the name of the Verein
     * @return a Verein entity
     */
    Verein findByNameIs(String name);

    /**
     * Finds a list of Verein entities whose name starts with a specific prefix.
     *
     * @param prefix the prefix to search for
     * @return a list of Verein entities
     */
    List<Verein> findByNameStartingWith(String prefix);

    /**
     * Finds all Verein entities located in a specific city (ort).
     *
     * @param ort the city to search for
     * @return a list of Verein entities
     */
    List<Verein> findByOrt(String ort);

    /**
     * Finds all Verein entities located in a specific postal code (plz).
     *
     * @param plz the postal code to search for
     * @return a list of Verein entities
     */
    List<Verein> findByPlz(String plz);

    /**
     * Finds all Verein entities by a specific abbreviation (abk).
     *
     * @param abk the abbreviation to search for
     * @return a list of Verein entities
     */
    List<Verein> findByAbk(String abk);
}package com.kcserver.repository;

import com.kcserver.entity.Person;
import com.kcserver.projection.PersonWithMitgliedschaften;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import java.util.List;

@RepositoryRestResource(excerptProjection = PersonWithMitgliedschaften.class)
public interface PersonRepository extends JpaRepository<Person, Long> {

    /**
     * Finds a list of Person entities by their last name.
     *
     * @param name the last name to search for
     * @return a list of Person entities
     */
    List<Person> findByName(String name);

    /**
     * Finds a single Person entity by their exact last name.
     *
     * @param name the exact last name to search for
     * @return a Person entity
     */
    Person findByNameIs(String name);

    /**
     * Finds a single Person entity by both first and last name.
     *
     * @param vorname the first name
     * @param name    the last name
     * @return a Person entity
     */
    Person findByVornameAndName(String vorname, String name);

    /**
     * Finds a list of Person entities whose last name starts with a specific prefix.
     *
     * @param prefix the prefix to search for
     * @return a list of Person entities
     */
    List<Person> findByNameStartingWith(String prefix);

    /**
     * Finds a list of Person entities whose first name starts with a specific prefix.
     *
     * @param prefix the prefix to search for
     * @return a list of Person entities
     */
    List<Person> findByVornameStartingWith(String prefix);

    /**
     * Finds all Person entities living in a specific city (ort).
     *
     * @param ort the city to search for
     * @return a list of Person entities
     */
    List<Person> findByOrt(String ort);

    /**
     * Finds all Person entities living in a specific postal code (plz).
     *
     * @param plz the postal code to search for
     * @return a list of Person entities
     */
    List<Person> findByPlz(String plz);
}package com.kcserver.repository;

import com.kcserver.entity.Mitglied;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MitgliedRepository extends JpaRepository<Mitglied, Long> {

        /**
         * Finds all Mitglied entities associated with a specific person by their ID.
         *
         * @param personId the ID of the person
         * @return a list of Mitglied entities
         */
        List<Mitglied> findByPersonMitgliedschaft_Id(Long personId);

        /**
         * Finds all Mitglied entities associated with a specific verein by their ID.
         *
         * @param vereinId the ID of the verein
         * @return a list of Mitglied entities
         */
        List<Mitglied> findByVereinMitgliedschaft_Id(Long vereinId);

        /**
         * Finds all Mitglied entities where `hauptVerein` is true.
         *
         * @param hauptVerein true or false indicating whether the Mitglied belongs to the main verein
         * @return a list of Mitglied entities
         */
        List<Mitglied> findByHauptVerein(boolean hauptVerein);

        @EntityGraph(attributePaths = {"personMitgliedschaft", "vereinMitgliedschaft"})
        List<Mitglied> findAll();
}package com.kcserver.sampleData.sampleService;

import com.kcserver.entity.Person;
import com.kcserver.repository.PersonRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SamplePersonService {
    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final PersonRepository personRepository;

    public SamplePersonService(PersonRepository personRepository) {
        this.personRepository = personRepository;
    }

    public void initialize() {
        if (personRepository.count() == 0) {
            logger.info("Loading sample Person data...");
            List<Person> samplePersons = List.of(
                    new Person("Schog", "Chris", "Ardennenstr. 82", "52076", "Aachen", "02408-81549", "Commerzbank Aachen", "DE671234567890", "DRESGENOW"),
                    new Person("Schog", "Hildegard", "Ardennenstr. 82", "52076", "Aachen", "02408-81549", "Commerzbank Aachen", "DE671234567890", "DRESGENOW")
            );
            personRepository.saveAll(samplePersons);
            logger.info("Sample Person data loaded successfully: {} records added.", samplePersons.size());
        } else {
            logger.info("Sample Person data already exists. Skipping initialization.");
        }
    }
}
package com.kcserver.sampleData.sampleService;

import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.repository.MitgliedRepository;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SampleMitgliedService {
    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final MitgliedRepository mitgliedRepository;
    private final PersonRepository personRepository;
    private final VereinRepository vereinRepository;

    public SampleMitgliedService(MitgliedRepository mitgliedRepository, PersonRepository personRepository,
                                 VereinRepository vereinRepository) {
        this.mitgliedRepository = mitgliedRepository;
        this.personRepository = personRepository;
        this.vereinRepository = vereinRepository;
    }
    public void initialize(){
        // Check if Mitglied data already exists
        if (mitgliedRepository.count() == 0) {
            logger.info("Loading sample Mitglied data...");

            // Retrieve an existing Person and Verein from the database
            Person existingPerson = personRepository.findByVornameAndName("Chris", "Schog");
            Verein existingVerein = vereinRepository.findByNameIs("Eschweiler Kanu Club");

            // Check if Person and Verein exist
            if (existingPerson != null && existingVerein != null) {
                logger.info("Person found: {} {}, ID: {}", existingPerson.getVorname(), existingPerson.getName(), existingPerson.getId());
                logger.info("Verein found: {}, ID: {}", existingVerein.getName(), existingVerein.getId());

                // Create a new Mitglied instance
                Mitglied mitglied = new Mitglied();
                mitglied.setPersonMitgliedschaft(existingPerson);
                mitglied.setVereinMitgliedschaft(existingVerein);
                mitglied.setFunktion("Geschäftsführer");
                mitglied.setHauptVerein(true);

                // Save the Mitglied instance
                mitgliedRepository.save(mitglied);
                logger.info("Sample Mitglied created: Person ID {}, Verein ID {}, Funktion {}",
                        mitglied.getPersonMitgliedschaft().getId(),
                        mitglied.getVereinMitgliedschaft().getId(),
                        mitglied.getFunktion());

                // Retrieve and log all HauptVerein members
                List<Mitglied> hauptVereinMembers = mitgliedRepository.findByHauptVerein(true);
                for (Mitglied member : hauptVereinMembers) {
                    logger.info("Member ID: {}, Person ID: {}, Verein ID: {}, Funktion: {}",
                            member.getId(),
                            member.getPersonMitgliedschaft().getId(),
                            member.getVereinMitgliedschaft().getId(),
                            member.getFunktion());
                }
            } else {
                logger.error("Required Person or Verein not found in the database. Sample Mitglied creation aborted.");
            }
        } else {
            logger.info("Sample Mitglied data already exists. Skipping initialization.");
        }
    }
}
package com.kcserver.sampleData.sampleService;

import com.kcserver.dto.VereinDTO;
import com.kcserver.entity.Verein;
import com.kcserver.repository.VereinRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class SampleVereinService {
    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final VereinRepository vereinRepository;

    public SampleVereinService(VereinRepository vereinRepository) {
        this.vereinRepository = vereinRepository;
    }

    public void initialize() {
        if (vereinRepository.count() == 0) { // Check if data already exists
            logger.info("Loading sample Verein data...");

            List<VereinDTO> sampleVereinDTOs = List.of(
                    new VereinDTO(
                            null, // ID will be auto-generated
                            "Eschweiler Kanu Club",
                            "EKC",
                            "Ardennenstr. 82",
                            "52076",
                            "Aachen",
                            "02408-81549",
                            "VR Bank e.G.",
                            "Eschweiler Kanu Club e.V.",
                            "Ardennenstr. 82, 52076 Aachen",
                            "DE45391629806106794020",
                            "GENODED1WUR"
                    ),
                    new VereinDTO(
                            null,
                            "Spielvereinigung Boich Thum",
                            "SVBT",
                            "",
                            "",
                            "Boich",
                            "",
                            "",
                            "Spielvereinigung Boich Thum e.V.",
                            "",
                            "",
                            ""
                    ),
                    new VereinDTO(
                            null,
                            "Oberhausener Kanu Club",
                            "OKC",
                            "",
                            "",
                            "Oberhausen",
                            "",
                            "",
                            "Oberhausener Kanu Club e.V.",
                            "",
                            "",
                            ""
                    ),
                    new VereinDTO(
                            null,
                            "Kanu Club Grün Gelb e.V.",
                            "KCG",
                            "",
                            "",
                            "Köln",
                            "",
                            "",
                            "Kanu Club Grün Gelb e.V.",
                            "",
                            "",
                            ""
                    )
            );

            // Convert DTOs to entities and save them
            List<Verein> sampleVereine = sampleVereinDTOs.stream()
                    .map(this::convertToEntity)
                    .collect(Collectors.toList());

            vereinRepository.saveAll(sampleVereine);

            logger.info("Sample Verein data loaded successfully: {} records added.", sampleVereine.size());
        } else logger.info("Sample Verein data already exists. Skipping initialization.");
    }
    /**
     * Converts a VereinDTO to a Verein entity.
     *
     * @param vereinDTO The VereinDTO to convert.
     * @return The corresponding Verein entity.
     */
    private Verein convertToEntity(VereinDTO vereinDTO) {
        return new Verein(
                vereinDTO.getName(),
                vereinDTO.getAbk(),
                vereinDTO.getStrasse(),
                vereinDTO.getPlz(),
                vereinDTO.getOrt(),
                vereinDTO.getTelefon(),
                vereinDTO.getBankName(),
                vereinDTO.getKontoInhaber(),
                vereinDTO.getKiAnschrift(),
                vereinDTO.getIban(),
                vereinDTO.getBic()
        );
    }
}
package com.kcserver.sampleData;

import com.kcserver.sampleData.sampleService.SampleMitgliedService;
import com.kcserver.sampleData.sampleService.SamplePersonService;
import com.kcserver.sampleData.sampleService.SampleVereinService;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

@Component
public class SampleDataInitializer {

    private static final Logger logger = LoggerFactory.getLogger(SampleDataInitializer.class);

    private final DataSource dataSource;
    private final SamplePersonService samplePersonService;
    private final SampleVereinService sampleVereinService;
    private final SampleMitgliedService sampleMitgliedService;

    // Constructor-based dependency injection
    public SampleDataInitializer(DataSource dataSource,
                                 SamplePersonService samplePersonService,
                                 SampleVereinService sampleVereinService,
                                 SampleMitgliedService sampleMitgliedService) {
        this.dataSource = dataSource;
        this.samplePersonService = samplePersonService;
        this.sampleVereinService = sampleVereinService;
        this.sampleMitgliedService = sampleMitgliedService;
    }

    @PostConstruct
    public void initializeSampleData() {
        // Load sample data
        loadSampleData();
    }

    private void loadSampleData() {
        logger.info("Loading sample data...");
        samplePersonService.initialize();
        sampleVereinService.initialize();
        sampleMitgliedService.initialize();
        logger.info("Sample data loaded successfully.");
    }

    @Bean
    public CommandLineRunner initializeDataRunner() {
        return args -> {
            logger.info("Starting CommandLineRunner-based data initialization...");
            loadSampleData();
            logger.info("CommandLineRunner-based data initialization completed.");
        };
    }
}package com.kcserver.config;

import com.kcserver.tenancy.TenantFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.server.resource.web.authentication.BearerTokenAuthenticationFilter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests(authz -> authz
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .jwkSetUri("http://localhost:9080/realms/KanuControl/protocol/openid-connect/certs")
                        )
                );

        // Register the TenantFilter AFTER the BearerTokenAuthenticationFilter
        http.addFilterAfter(new TenantFilter(), BearerTokenAuthenticationFilter.class);

        return http.build();
    }
}package com.kcserver.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins(
                        "http://localhost:3000",
                        "http://localhost:5173",
                        "http://your-production-url.com"
                ) // Add production URL(s) here
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // Include OPTIONS for preflight requests
                .allowedHeaders("*") // Allow all headers
                .allowCredentials(true); // Allow cookies and credentials
    }
}package com.kcserver.entity;

import jakarta.persistence.Column;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Column;
import jakarta.persistence.MappedSuperclass;

import java.time.LocalDateTime;

@MappedSuperclass
public abstract class Auditable {

    @Column(name = "created_date", updatable = false)
    private LocalDateTime createdDate;

    @Column(name = "last_modified_date")
    private LocalDateTime lastModifiedDate;

    @PrePersist
    public void prePersist() {
        this.createdDate = LocalDateTime.now();
        this.lastModifiedDate = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate() {
        this.lastModifiedDate = LocalDateTime.now();
    }

    // Getters and setters

}package com.kcserver.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.*;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@Table(name = "mitglied", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"person_id", "verein_id"})
})
public class Mitglied extends Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    @Column(name = "id")
    private Long id;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "verein_id", nullable = false)
    @ToString.Exclude
    private Verein vereinMitgliedschaft;

    @NotNull
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "person_id", nullable = false)
    @ToString.Exclude
    private Person personMitgliedschaft;

    @Column(name = "funktion")
    private String funktion;

    @NotNull
    @Column(name = "haupt_verein")
    private Boolean hauptVerein;

    // Constructor with specific fields
    public Mitglied(Verein vereinMitgliedschaft, Person personMitgliedschaft, String funktion, Boolean hauptVerein) {
        this.vereinMitgliedschaft = vereinMitgliedschaft;
        this.personMitgliedschaft = personMitgliedschaft;
        this.funktion = funktion;
        this.hauptVerein = hauptVerein;
    }

    public boolean isHauptVerein() {
        return hauptVerein;
    }

    public void setHauptVerein(boolean hauptVerein) {
        this.hauptVerein = hauptVerein;
    }

    // Custom setter for Verein
    public void setVerein(Verein verein) {
        this.vereinMitgliedschaft = verein;
    }

    // Custom getter for Verein
    public Verein getVerein() {
        return this.vereinMitgliedschaft;
    }

    // Custom setter for Person
    public void setPerson(Person person) {
        this.personMitgliedschaft = person;
    }

    // Custom getter for Person
    public Person getPerson() {
        return this.personMitgliedschaft;
    }
}package com.kcserver.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@Table(name = "person")
@Entity
public class Person extends Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    @Column(name = "id")
    private Long id;

    @NotNull
    @Size(min = 2, max = 100)
    @Column(name = "name")
    private String name;

    @NotNull
    @Size(min = 2, max = 100)
    @Column(name = "vorname")
    private String vorname;

    @Column(name = "strasse")
    private String strasse;

    @Column(name = "plz")
    private String plz;

    @Column(name = "ort")
    private String ort;

    @Column(name = "telefon")
    private String telefon;

    @Size(max = 255)
    @Column(name = "bank_name")
    private String bankName;

    // @Pattern(regexp = "^[A-Z0-9]{22}$") // Validate IBAN with a length of 22 (standard for many countries)
    @Column(name = "iban")
    private String iban;

    // @Pattern(regexp = "^[A-Z0-9]{8,11}$") // Validate BIC format with length between 8-11
    @Column(name = "bic")
    private String bic;

    @OneToMany(mappedBy = "personMitgliedschaft", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Mitglied> mitgliedschaften = new ArrayList<>(); // Initialize with an empty list

    // Helper method to add a Mitglied
    public void addMitglied(Mitglied mitglied) {
        mitgliedschaften.add(mitglied);
        mitglied.setPerson(this);
    }

    // Helper method to remove a Mitglied
    public void removeMitglied(Mitglied mitglied) {
        mitgliedschaften.remove(mitglied);
        mitglied.setPerson(null);
    }


    public
    Person(String name, String vorname, String strasse, String plz, String ort,
           String telefon, String bankName, String iban, String bic) {
        this.name = name;
        this.vorname = vorname;
        this.strasse = strasse;
        this.plz = plz;
        this.ort = ort;
        this.telefon = telefon;
        this.bankName = bankName;
        this.iban = iban;
        this.bic = bic;
    }
}package com.kcserver.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.*;

@Data
@Entity(name = "verein")
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = {"iban", "bic"}) // Optionally exclude sensitive fields from string representation
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false)
@Table
public class Verein extends Auditable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    @Column(name = "id")
    private Long id;

    @NotNull
    @Size(min = 2, max = 100)
    @Column(name = "name")
    private String name;

    @NotNull
    @Size(min = 1, max = 10)
    @Column(name = "abk")
    private String abk;

    @Column(name = "strasse")
    private String strasse;

    @Column(name = "plz")
    private String plz;

    @Column(name = "ort")
    private String ort;

    @Column(name = "telefon")
    private String telefon;

    @Size(max = 255)
    @Column(name = "bank_name")
    private String bankName;

    @Size(max = 255)
    @Column(name = "konto_inhaber")
    private String kontoInhaber;

    @Size(max = 255)
    @Column(name = "ki_anschrift")
    private String kiAnschrift;

    // @Pattern(regexp = "^[A-Z0-9]+$", message = "Invalid IBAN format")
    @Column(name = "iban")
    private String iban;

    // @Pattern(regexp = "^[A-Z0-9]+$", message = "Invalid BIC format")
    @Column(name = "bic")
    private String bic;


    public
    Verein(String name, String abk, String strasse, String plz, String ort,
           String telefon, String bankName, String kontoInhaber,
           String kiAnschrift, String iban, String bic) {
        this.name = name;
        this.abk = abk;
        this.strasse = strasse;
        this.plz = plz;
        this.ort = ort;
        this.telefon = telefon;
        this.bankName = bankName;
        this.kontoInhaber = kontoInhaber;
        this.kiAnschrift = kiAnschrift;
        this.iban = iban;
        this.bic = bic;
    }
}package com.kcserver.mapper;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.dto.PersonDTO;
import com.kcserver.dto.VereinDTO;
import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import org.mapstruct.*;

@Mapper(
        componentModel = "spring",
        uses = {PersonRepository.class, VereinRepository.class})
public interface EntityMapper {

    // Person Mappings
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "vorname", source = "vorname")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    PersonDTO toPersonDTO(Person person);

    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "vorname", source = "vorname")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    Person toPersonEntity(PersonDTO personDTO);

    @Mapping(target = "id", ignore = true)
    void updatePersonFromDTO(PersonDTO personDTO, @MappingTarget Person person);

    // Verein Mappings
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "abk", source = "abk")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "kontoInhaber", source = "kontoInhaber")
    @Mapping(target = "kiAnschrift", source = "kiAnschrift")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    VereinDTO toVereinDTO(Verein verein);

    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    @Mapping(target = "abk", source = "abk")
    @Mapping(target = "strasse", source = "strasse")
    @Mapping(target = "plz", source = "plz")
    @Mapping(target = "ort", source = "ort")
    @Mapping(target = "telefon", source = "telefon")
    @Mapping(target = "bankName", source = "bankName")
    @Mapping(target = "kontoInhaber", source = "kontoInhaber")
    @Mapping(target = "kiAnschrift", source = "kiAnschrift")
    @Mapping(target = "iban", source = "iban")
    @Mapping(target = "bic", source = "bic")
    Verein toVereinEntity(VereinDTO vereinDTO);

    @Mapping(target = "id", ignore = true)
    void updateVereinFromDTO(VereinDTO vereinDTO, @MappingTarget Verein verein);

    // Mitglied Mappings
    @Mapping(source = "personMitgliedschaft.id", target = "personId")
    @Mapping(source = "vereinMitgliedschaft.id", target = "vereinId")
    @Mapping(source = "vereinMitgliedschaft.name", target = "vereinName")
    @Mapping(source = "vereinMitgliedschaft.abk", target = "vereinAbk")
    @Mapping(source = "funktion", target = "funktion")
    @Mapping(source = "hauptVerein", target = "hauptVerein")
    MitgliedDTO toMitgliedDTO(Mitglied mitglied);

    @Mapping(target = "personMitgliedschaft", ignore = true) // Explicitly ignore
    @Mapping(target = "vereinMitgliedschaft", ignore = true) // Explicitly ignore
    @Mapping(target = "person", ignore = true) // Explicitly ignore
    @Mapping(target = "verein", ignore = true) // Explicitly ignore
    @Mapping(source = "funktion", target = "funktion")
    @Mapping(source = "hauptVerein", target = "hauptVerein")
    Mitglied toMitgliedEntity(MitgliedDTO mitgliedDTO);

    @AfterMapping
    default void mapMitgliedAssociations(MitgliedDTO mitgliedDTO, @MappingTarget Mitglied mitglied,
                                         @Context PersonRepository personRepository,
                                         @Context VereinRepository vereinRepository) {
        if (mitgliedDTO.getPersonId() != null) {
            Person person = personRepository.findById(mitgliedDTO.getPersonId())
                    .orElseThrow(() -> new IllegalArgumentException("Invalid person ID"));
            mitglied.setPersonMitgliedschaft(person);
        }
        if (mitgliedDTO.getVereinId() != null) {
            Verein verein = vereinRepository.findById(mitgliedDTO.getVereinId())
                    .orElseThrow(() -> new IllegalArgumentException("Invalid verein ID"));
            mitglied.setVereinMitgliedschaft(verein);
        }
    }
}package com.kcserver.controller;

import com.kcserver.dto.VereinDTO;
import com.kcserver.service.VereinService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/verein")
public class VereinController {

    private final VereinService vereinService;

    @Autowired
    public VereinController(VereinService vereinService) {
        this.vereinService = vereinService;
    }

    /**
     * Retrieve all Vereine as VereinDTOs.
     *
     * @return List of VereinDTOs.
     */
    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<VereinDTO>> getAllVereine() {
        List<VereinDTO> vereinDTOs = vereinService.getAllVereine();
        return ResponseEntity.ok(vereinDTOs);
    }

    /**
     * Retrieve a Verein by its ID as VereinDTO.
     *
     * @param id The ID of the Verein.
     * @return The VereinDTO or 404 if not found.
     */
    @GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<VereinDTO> getVereinById(@PathVariable Long id) {
        VereinDTO vereinDTO = vereinService.getVerein(id);
        return ResponseEntity.ok(vereinDTO);
    }

    /**
     * Create a new Verein from a VereinDTO.
     *
     * @param vereinDTO The VereinDTO to be created.
     * @return The created VereinDTO.
     */
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<VereinDTO> createVerein(@Valid @RequestBody VereinDTO vereinDTO) {
        VereinDTO createdVereinDTO = vereinService.createVerein(vereinDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdVereinDTO);
    }

    /**
     * Update an existing Verein by its ID using VereinDTO.
     *
     * @param id            The ID of the Verein to be updated.
     * @param updatedVereinDTO The updated VereinDTO data.
     * @return The updated VereinDTO or 404 if not found.
     */
    @PutMapping(value = "/{id}", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<VereinDTO> updateVerein(@PathVariable Long id, @Valid @RequestBody VereinDTO updatedVereinDTO) {
        VereinDTO updatedVereinDTOResult = vereinService.updateVerein(id, updatedVereinDTO);
        return ResponseEntity.ok(updatedVereinDTOResult);
    }

    /**
     * Delete a Verein by its ID.
     *
     * @param id The ID of the Verein to delete.
     * @return No content if successful, or 404 if not found.
     */
    @DeleteMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Void> deleteVerein(@PathVariable Long id) {
        boolean isDeleted = vereinService.deleteVerein(id);
        if (isDeleted) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }
}
package com.kcserver.controller;

import com.kcserver.dto.PersonDTO;
import com.kcserver.tenancy.TenantContext;
import com.kcserver.service.PersonService;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/person")
public class PersonController {

    private final PersonService personService;

    private static final Logger logger = LoggerFactory.getLogger(PersonController.class);

    @Autowired
    public PersonController(PersonService personService) {
        this.personService = personService;
    }

    /**
     * Retrieve all persons as PersonDTOs, including their Mitgliedschaften and related Verein data.
     *
     * @return List of PersonDTOs.
     */
    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<PersonDTO>> getAllPersons() {
        List<PersonDTO> personDTOs = personService.getAllPersonsWithDetails();
        logger.info("Current Tenant: {}", TenantContext.getTenantId());
        return ResponseEntity.ok(personDTOs);
    }

    /**
     * Retrieve a person by their ID as PersonDTO, including their Mitgliedschaften and related Verein data.
     *
     * @param id The ID of the person.
     * @return The PersonDTO or 404 if not found.
     */
    @GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<PersonDTO> getPersonById(@PathVariable Long id) {
        PersonDTO personDTO = personService.getPersonWithDetails(id);
        logger.info("Current Tenant: {}", TenantContext.getTenantId());
        return ResponseEntity.ok(personDTO);
    }

    /**
     * Create a new person from a PersonDTO.
     *
     * @param personDTO The PersonDTO to be created.
     * @return The created PersonDTO.
     */
    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<PersonDTO> createPerson(@Valid @RequestBody PersonDTO personDTO) {
        PersonDTO createdPersonDTO = personService.createPerson(personDTO);
        logger.info("Current Tenant: {}", TenantContext.getTenantId());
        return ResponseEntity.status(HttpStatus.CREATED).body(createdPersonDTO);
    }

    /**
     * Update an existing person by their ID using PersonDTO.
     *
     * @param id         The ID of the person to be updated.
     * @param personDTO The updated PersonDTO data.
     * @return The updated PersonDTO or 404 if not found.
     */
    @PutMapping(value = "/{id}", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<PersonDTO> updatePerson(@PathVariable Long id, @Valid @RequestBody PersonDTO personDTO) {

        logger.info("Received PUT request to update person with ID: {} and payload: {}", id, personDTO);

        try {
            PersonDTO updatedPerson = personService.updatePerson(id, personDTO);
            logger.info("Successfully updated person with ID: {}", id);
            logger.info("Current Tenant: {}", TenantContext.getTenantId());
            return ResponseEntity.ok(updatedPerson);
        } catch (Exception e) {
            logger.error("Error updating person with ID: {}", id, e);
            throw e; // Let Spring handle and return the appropriate error response
        }
    }

    /**
     * Delete a person by their ID.
     *
     * @param id The ID of the person to delete.
     * @return No content if successful, or 404 if not found.
     */
    @DeleteMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Void> deletePerson(@PathVariable Long id) {
        boolean isDeleted = personService.deletePerson(id);
        if (isDeleted) {
            logger.info("Current Tenant: {}", TenantContext.getTenantId());
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }
}
package com.kcserver.controller;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.service.MitgliedService;
import com.kcserver.service.PersonService;
import com.kcserver.service.VereinService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/mitglied")
public class MitgliedController {

    private static final Logger logger = LoggerFactory.getLogger(MitgliedController.class);

    private final MitgliedService mitgliedService;
    private final PersonService personService;
    private final VereinService vereinService;

    @Autowired
    public MitgliedController(MitgliedService mitgliedService, PersonService personService, VereinService vereinService) {
        this.mitgliedService = mitgliedService;
        this.personService = personService;
        this.vereinService = vereinService;
    }

    /**
     * Creates a new Mitglied entity.
     *
     * @param mitgliedDTO the DTO containing Mitglied details
     * @return ResponseEntity with the created MitgliedDTO
     */
    @PostMapping
    public ResponseEntity<MitgliedDTO> createMitglied(@RequestBody @Valid MitgliedDTO mitgliedDTO) {
        try {
            // Validate that Person ID and Verein ID are not null
            Long personId = mitgliedDTO.getPersonId();
            Long vereinId = mitgliedDTO.getVereinId();

            if (personId == null || vereinId == null) {
                throw new IllegalArgumentException("Person ID and Verein ID must not be null");
            }

            // Fetch Person and Verein entities
            Person person = personService.getPersonEntityById(personId);
            Verein verein = vereinService.getVereinEntityById(vereinId);

            // Create the Mitglied and return the DTO
            MitgliedDTO createdMitgliedDTO = mitgliedService.createMitglied(
                    person,
                    verein,
                    mitgliedDTO.getFunktion(),
                    mitgliedDTO.getHauptVerein()
            );

            logger.info("Created new Mitglied: {}", createdMitgliedDTO);
            return ResponseEntity.status(HttpStatus.CREATED).body(createdMitgliedDTO);
        } catch (IllegalArgumentException e) {
            logger.error("Validation error creating Mitglied: {}", e.getMessage());
            return ResponseEntity.badRequest().body(null);
        } catch (Exception e) {
            logger.error("Unexpected error creating Mitglied: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    /**
     * Retrieves all Mitglied entries for a given Person ID.
     *
     * @param personId the ID of the person
     * @return ResponseEntity containing a list of MitgliedDTOs
     */
    @GetMapping("/person/{personId}")
    public ResponseEntity<List<MitgliedDTO>> getMitgliedByPerson(@PathVariable @NotNull Long personId) {
        try {
            List<MitgliedDTO> mitgliedDTOs = mitgliedService.getMitgliedByPersonId(personId);

            logger.info("Retrieved {} Mitglied entries for Person ID {}", mitgliedDTOs.size(), personId);
            return ResponseEntity.ok(mitgliedDTOs);
        } catch (Exception e) {
            logger.error("Error retrieving Mitglied for Person ID {}: {}", personId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    /**
     * Retrieves all Mitglied entries for a given Verein ID.
     *
     * @param vereinId the ID of the Verein
     * @return ResponseEntity containing a list of MitgliedDTOs
     */
    @GetMapping("/verein/{vereinId}")
    public ResponseEntity<List<MitgliedDTO>> getMitgliedByVerein(@PathVariable @NotNull Long vereinId) {
        try {
            List<MitgliedDTO> mitgliedDTOs = mitgliedService.getMitgliedByVereinId(vereinId);

            logger.info("Retrieved {} Mitglied entries for Verein ID {}", mitgliedDTOs.size(), vereinId);
            return ResponseEntity.ok(mitgliedDTOs);
        } catch (Exception e) {
            logger.error("Error retrieving Mitglied for Verein ID {}: {}", vereinId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    /**
     * Deletes a Mitglied by its ID.
     *
     * @param mitgliedId the ID of the Mitglied to delete
     * @return ResponseEntity with no content if successful
     */
    @DeleteMapping("/{mitgliedId}")
    public ResponseEntity<Void> deleteMitglied(@PathVariable @NotNull Long mitgliedId) {
        try {
            mitgliedService.deleteMitglied(mitgliedId);
            logger.info("Deleted Mitglied with ID: {}", mitgliedId);
            return ResponseEntity.noContent().build();
        } catch (IllegalArgumentException e) {
            logger.error("Validation error deleting Mitglied with ID {}: {}", mitgliedId, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            logger.error("Unexpected error deleting Mitglied with ID {}: {}", mitgliedId, e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}package com.kcserver.tenancy;

public class TenantContext {

    private static final ThreadLocal<String> currentTenant = new ThreadLocal<>();

    // Set the tenant identifier
    public static void setTenantId(String tenantId) {
        currentTenant.set(tenantId);
    }

    // Get the tenant identifier
    public static String getTenantId() {
        return currentTenant.get();
    }

    // Clear the tenant identifier (important to avoid memory leaks)
    public static void clear() {
        currentTenant.remove();
    }
}package com.kcserver.tenancy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

public class TenantFilter extends OncePerRequestFilter {

    private static final Logger logger = LoggerFactory.getLogger(TenantFilter.class);

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        // Retrieve the current Authentication
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        // Check if Authentication is null or invalid
        if (authentication == null || !(authentication.getPrincipal() instanceof Jwt jwt)) {
            logger.warn("No valid authentication found in SecurityContext.");
            filterChain.doFilter(request, response);
            return;
        }

        // Extract the "groups" claim from the JWT
        Object groupsClaim = jwt.getClaim("groups");

        if (groupsClaim instanceof List<?> groups && !groups.isEmpty()) {
            String tenantName = groups.get(0).toString(); // Use the first group as the tenant name
            TenantContext.setTenantId(tenantName);
            logger.info("Tenant extracted: {}", tenantName);
        } else {
            logger.warn("No 'groups' claim found in JWT.");
        }

        // Continue the filter chain
        filterChain.doFilter(request, response);
    }
}package com.kcserver.service;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.repository.MitgliedRepository;
import com.kcserver.mapper.EntityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class MitgliedService {

    private final MitgliedRepository mitgliedRepository;
    private final EntityMapper mapper;

    @Autowired
    public MitgliedService(MitgliedRepository mitgliedRepository, EntityMapper mapper) {
        this.mitgliedRepository = mitgliedRepository;
        this.mapper = mapper;
    }

    /**
     * Creates a new Mitglied entity, saves it to the database, and returns the corresponding DTO.
     *
     * @param person      the person associated with the Mitglied
     * @param verein      the verein associated with the Mitglied
     * @param funktion    the role of the Mitglied
     * @param hauptVerein indicates whether this is the main verein for the person
     * @return the saved Mitglied as a DTO
     */
    public MitgliedDTO createMitglied(Person person, Verein verein, String funktion, Boolean hauptVerein) {
        if (person == null || verein == null) {
            throw new IllegalArgumentException("Person and Verein cannot be null");
        }

        Mitglied mitglied = new Mitglied();
        mitglied.setPersonMitgliedschaft(person);
        mitglied.setVereinMitgliedschaft(verein);
        mitglied.setFunktion(funktion);
        mitglied.setHauptVerein(hauptVerein);

        Mitglied savedMitglied = mitgliedRepository.save(mitglied);
        return mapper.toMitgliedDTO(savedMitglied);
    }

    /**
     * Updates an existing Mitglied entity.
     *
     * @param mitgliedId the ID of the Mitglied to update
     * @param funktion   the updated role of the Mitglied
     * @param hauptVerein indicates whether this is the main verein
     * @return the updated Mitglied as a DTO
     */
    public MitgliedDTO updateMitglied(Long mitgliedId, String funktion, Boolean hauptVerein) {
        Mitglied mitglied = mitgliedRepository.findById(mitgliedId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Mitglied not found"));

        mitglied.setFunktion(funktion);
        mitglied.setHauptVerein(hauptVerein);

        Mitglied updatedMitglied = mitgliedRepository.save(mitglied);
        return mapper.toMitgliedDTO(updatedMitglied);
    }

    /**
     * Retrieves all Mitglied entities associated with a specific Person and converts them to DTOs.
     *
     * @param personId the ID of the person
     * @return a list of MitgliedDTOs
     */
    public List<MitgliedDTO> getMitgliedByPersonId(Long personId) {
        return mitgliedRepository.findByPersonMitgliedschaft_Id(personId).stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves all Mitglied entities associated with a specific Verein and converts them to DTOs.
     *
     * @param vereinId the ID of the verein
     * @return a list of MitgliedDTOs
     */
    public List<MitgliedDTO> getMitgliedByVereinId(Long vereinId) {
        return mitgliedRepository.findByVereinMitgliedschaft_Id(vereinId).stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deletes a Mitglied by its ID.
     *
     * @param mitgliedId the ID of the Mitglied to delete
     */
    public void deleteMitglied(Long mitgliedId) {
        if (!mitgliedRepository.existsById(mitgliedId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Mitglied not found");
        }
        mitgliedRepository.deleteById(mitgliedId);
    }

    /**
     * Retrieves all Mitglieds and converts them to DTOs.
     *
     * @return a list of all MitgliedDTOs
     */
    public List<MitgliedDTO> getAllMitglieds() {
        return mitgliedRepository.findAll().stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList());
    }
}package com.kcserver.service;

import com.kcserver.dto.MitgliedDTO;
import com.kcserver.dto.PersonDTO;
import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import com.kcserver.mapper.EntityMapper;
import com.kcserver.repository.PersonRepository;
import com.kcserver.repository.VereinRepository;
import com.kcserver.sampleData.sampleService.SamplePersonService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
public class PersonService {

    private static final Logger logger = LoggerFactory.getLogger(SamplePersonService.class);

    private final PersonRepository personRepository;
    private final VereinRepository vereinRepository;
    private final EntityMapper mapper;

    @Autowired
    public PersonService(PersonRepository personRepository, VereinRepository vereinRepository, EntityMapper mapper) {
        this.personRepository = personRepository;
        this.vereinRepository = vereinRepository;
        this.mapper = mapper;
    }

    /**
     * Retrieve all persons as PersonDTOs.
     *
     * @return List of PersonDTOs.
     */
    @Transactional(readOnly = true)
    public List<PersonDTO> getAllPersons() {
        return personRepository.findAll().stream()
                .map(mapper::toPersonDTO)
                .collect(Collectors.toList());
    }

    /**
     * Retrieve a person by their ID and return as PersonDTO.
     *
     * @param id The ID of the person.
     * @return The PersonDTO.
     * @throws ResponseStatusException if the person is not found.
     */
    public PersonDTO getPerson(long id) {
        Person person = personRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found"));
        return mapper.toPersonDTO(person);
    }

    /**
     * Retrieve a Person entity by its ID.
     *
     * @param id The ID of the person.
     * @return The Person entity.
     * @throws ResponseStatusException if the person is not found.
     */
    public Person getPersonEntityById(long id) {
        return personRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found"));
    }

    public PersonDTO getPersonWithDetails(long id) {
        Person person = personRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found"));

        PersonDTO personDTO = mapper.toPersonDTO(person);
        personDTO.setMitgliedschaften(person.getMitgliedschaften().stream()
                .map(mapper::toMitgliedDTO)
                .collect(Collectors.toList()));
        return personDTO;
    }
    @Transactional(readOnly = true)
    public List<PersonDTO> getAllPersonsWithDetails() {
        return personRepository.findAll().stream()
                .map(person -> {
                    PersonDTO personDTO = mapper.toPersonDTO(person);
                    personDTO.setMitgliedschaften(person.getMitgliedschaften().stream()
                            .map(mapper::toMitgliedDTO)
                            .collect(Collectors.toList()));
                    return personDTO;
                })
                .collect(Collectors.toList());
    }

    /**
     * Create a new person from PersonDTO.
     *
     * @param personDTO The PersonDTO to be created.
     * @return The created PersonDTO.
     */
    public PersonDTO createPerson(PersonDTO personDTO) {
        Person person = mapper.toPersonEntity(personDTO);

        // Handle Mitgliedschaften if provided
        if (personDTO.getMitgliedschaften() != null) {
            personDTO.getMitgliedschaften().forEach(mitgliedDTO -> {
                Verein verein = vereinRepository.findById(mitgliedDTO.getVereinId())
                        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));
                Mitglied mitglied = new Mitglied(
                        verein,
                        person,
                        mitgliedDTO.getFunktion(),
                        mitgliedDTO.getHauptVerein()
                );
                person.getMitgliedschaften().add(mitglied);
            });
        }

        Person savedPerson = personRepository.save(person);
        return mapper.toPersonDTO(savedPerson);
    }

    /**
     * Update an existing person by their ID using PersonDTO.
     *
     * @param id        The ID of the person to be updated.
     * @param personDTO The updated PersonDTO data.
     * @return The updated PersonDTO.
     * @throws ResponseStatusException if the person is not found.
     */
    public PersonDTO updatePerson(long id, PersonDTO personDTO) {
        logger.info("Updating person with ID: {} using data: {}", id, personDTO);

        Person existingPerson = personRepository.findById(id)
                .orElseThrow(() -> {
                    logger.error("Person with ID: {} not found", id);
                    return new ResponseStatusException(HttpStatus.NOT_FOUND, "Person not found");
                });

        logger.debug("Found person: {}", existingPerson);

        // Map DTO to entity
        mapper.updatePersonFromDTO(personDTO, existingPerson);
        logger.debug("Mapped fields from DTO to entity for ID: {}", id);

        // Clear existing Mitgliedschaften
        logger.info("Payload received for update: {}", personDTO);
        if (existingPerson.getMitgliedschaften() == null) {
            logger.error("Mitgliedschaften is null for person ID {}", id);
            existingPerson.setMitgliedschaften(new ArrayList<>());
        } else {
            logger.info("Existing Mitgliedschaften: {}", existingPerson.getMitgliedschaften());
            existingPerson.getMitgliedschaften().clear();
        }

        // Rebuild Mitgliedschaften from the DTO
        if (personDTO.getMitgliedschaften() != null) {
            // Map of existing Mitgliedschaften by Verein ID for quick lookup
            Map<Long, Mitglied> existingMitgliedMap = existingPerson.getMitgliedschaften().stream()
                    .collect(Collectors.toMap(m -> m.getVerein().getId(), Function.identity()));

            for (MitgliedDTO mitgliedDTO : personDTO.getMitgliedschaften()) {
                Verein verein = vereinRepository.findById(mitgliedDTO.getVereinId())
                        .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));

                Mitglied mitglied = existingMitgliedMap.get(verein.getId());
                if (mitglied == null) {
                    // New Mitglied
                    mitglied = new Mitglied();
                    mitglied.setPerson(existingPerson);
                    mitglied.setVerein(verein);
                    existingPerson.getMitgliedschaften().add(mitglied);
                }

                // Update fields
                mitglied.setFunktion(mitgliedDTO.getFunktion());
                mitglied.setHauptVerein(mitgliedDTO.getHauptVerein());
            }

            // Remove Mitgliedschaften not in the DTO
            Set<Long> incomingVereinIds = personDTO.getMitgliedschaften().stream()
                    .map(MitgliedDTO::getVereinId)
                    .collect(Collectors.toSet());

            existingPerson.getMitgliedschaften().removeIf(m -> !incomingVereinIds.contains(m.getVerein().getId()));
        }

        Person updatedPerson = personRepository.save(existingPerson);
        logger.info("Successfully updated person with ID: {}", id);
        return mapper.toPersonDTO(updatedPerson);
    }
    /**
     * Delete a person by their ID.
     *
     * @param id The ID of the person to delete.
     * @return true if successful, false otherwise.
     */
    public boolean deletePerson(long id) {
        if (personRepository.existsById(id)) {
            personRepository.deleteById(id);
            return true;
        }
        return false;
    }
}package com.kcserver.service;

import com.kcserver.dto.VereinDTO;
import com.kcserver.entity.Verein;
import com.kcserver.repository.VereinRepository;
import com.kcserver.mapper.EntityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class VereinService {

    private final VereinRepository vereinRepository;
    private final EntityMapper mapper;

    @Autowired
    public VereinService(VereinRepository vereinRepository, EntityMapper mapper) {
        this.vereinRepository = vereinRepository;
        this.mapper = mapper;
    }

    /**
     * Retrieve all Vereine as VereinDTOs.
     *
     * @return List of VereinDTOs.
     */
    public List<VereinDTO> getAllVereine() {
        return vereinRepository.findAll().stream()
                .map(mapper::toVereinDTO)
                .collect(Collectors.toList());
    }

    /**
     * Retrieve a Verein by its ID and return as VereinDTO.
     *
     * @param id The ID of the Verein.
     * @return The VereinDTO.
     * @throws ResponseStatusException if the Verein is not found.
     */
    public VereinDTO getVerein(long id) {
        Verein verein = vereinRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));
        return mapper.toVereinDTO(verein);
    }

    /**
     * Retrieve a Verein entity by its ID.
     *
     * @param id The ID of the Verein.
     * @return The Verein entity.
     * @throws ResponseStatusException if the Verein is not found.
     */
    public Verein getVereinEntityById(long id) {
        return vereinRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));
    }

    /**
     * Create a new Verein from VereinDTO.
     *
     * @param vereinDTO The VereinDTO to be created.
     * @return The created VereinDTO.
     */
    public VereinDTO createVerein(VereinDTO vereinDTO) {
        Verein verein = mapper.toVereinEntity(vereinDTO);
        Verein savedVerein = vereinRepository.save(verein);
        return mapper.toVereinDTO(savedVerein);
    }

    /**
     * Update an existing Verein by its ID using VereinDTO.
     *
     * @param id        The ID of the Verein to be updated.
     * @param vereinDTO The updated VereinDTO data.
     * @return The updated VereinDTO.
     * @throws ResponseStatusException if the Verein is not found.
     */
    public VereinDTO updateVerein(long id, VereinDTO vereinDTO) {
        Verein existingVerein = vereinRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Verein not found"));

        mapper.updateVereinFromDTO(vereinDTO, existingVerein);

        Verein updatedVerein = vereinRepository.save(existingVerein);
        return mapper.toVereinDTO(updatedVerein);
    }

    /**
     * Delete a Verein by its ID.
     *
     * @param id The ID of the Verein to delete.
     * @return true if successful, false otherwise.
     */
    public boolean deleteVerein(long id) {
        if (vereinRepository.existsById(id)) {
            vereinRepository.deleteById(id);
            return true;
        }
        return false;
    }
}package com.kcserver.exception;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<String> handleDataIntegrityViolationException(DataIntegrityViolationException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body("Duplicate entry detected.");
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        // Fallback for unexpected exceptions
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred: " + ex.getMessage());
    }
}package com.kcserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.stereotype.Component;

@Configuration
@EnableAutoConfiguration
@ComponentScan
@Component
@EnableScheduling
@SpringBootApplication
public class KC_Server {

	public static void main(String[] args) {
		SpringApplication.run(KC_Server.class, args);
		System.out.println("KC Server is running...");
	}
}package com.kcserver.projection;

import com.kcserver.entity.Mitglied;
import com.kcserver.entity.Person;
import com.kcserver.entity.Verein;
import org.springframework.data.rest.core.config.Projection;

import java.util.List;

@Projection(name = "personWithMitgliedschaften", types = {Person.class})
public interface PersonWithMitgliedschaften {
    String getName();
    String getVorname();
    String getStrasse();
    String getPlz();
    String getOrt();
    String getTelefon();
    String getBankName();
    String getIban();
    String getBic();

    List<MitgliedProjection> getMitgliedschaften();
}

@Projection(name = "mitgliedProjection", types = {Mitglied.class})
interface MitgliedProjection {
    Long getId();
    String getFunktion();
    Boolean getHauptVerein();
    VereinProjection getVereinMitgliedschaft();
}

@Projection(name = "vereinProjection", types = {Verein.class})
interface VereinProjection {
    Long getId();
    String getName();
    String getAbk();
}